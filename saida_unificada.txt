=== accounts/backends.py ===
# myapp/backends.py

from django.contrib.auth.backends import ModelBackend
from django.contrib.auth import get_user_model

UserModel = get_user_model()

class EmailBackend(ModelBackend):
    """
    Backend de autenticação personalizado que permite autenticação com email.
    """

    def authenticate(self, request, username=None, password=None, **kwargs):
        try:
            user = UserModel.objects.get(email=username)
            if user.check_password(password):
                return user
        except UserModel.DoesNotExist:
            return None


=== accounts/views.py ===
import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.contrib.auth import login, authenticate, logout, views as auth_views
from django.contrib.auth.decorators import login_required
from django.contrib.sites.shortcuts import get_current_site
from django.core.mail import send_mail
from django.conf import settings

from allauth.account.views import ConfirmEmailView
from allauth.account.utils import send_email_confirmation

from .forms import CustomUserCreationForm, TokenForm, EmailAuthenticationForm, UserTokenForm
from .models import UserToken, Profile
from ai_config.forms import UserAITrainingFileForm  
from ai_config.models import AITrainingFile
from api.constants import AIClientType

logger = logging.getLogger(__name__)

def register_view(request):
    if request.method == 'POST':
        form = CustomUserCreationForm(request.POST)
        if form.is_valid():
            try:
                user = form.save()
                send_email_confirmation(request, user)  # Envia o email de confirmação
                logger.info(f"Novo usuário registrado: {user.email}")
                messages.success(request, 'Conta criada com sucesso! Por favor, verifique seu email para ativação.')
                return redirect('login')
            except Exception as e:
                logger.error(f"Erro ao registrar usuário: {e}")
                messages.error(request, 'Ocorreu um erro ao criar sua conta. Por favor, tente novamente.')
        else:
            logger.warning(f"Formulário de registro inválido: {form.errors}")
    else:
        form = CustomUserCreationForm()
    return render(request, 'accounts/registration/register.html', {'form': form})

def login_view(request):
    if request.user.is_authenticated:
        return redirect('manage_tokens')
    if request.method == 'POST':
        form = EmailAuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            logger.info(f"Usuário {user.email} logado com sucesso.")
            messages.success(request, f'Bem-vindo, {user.email}!')
            return redirect('manage_tokens')
        else:
            logger.warning(f"Tentativa de login falhou: {form.errors}")
    else:
        form = EmailAuthenticationForm()
    return render(request, 'accounts/registration/login.html', {'form': form})

@login_required
def logout_view(request):
    logger.info(f"Usuário {request.user.email} fez logout.")
    logout(request)
    messages.success(request, 'Logout realizado com sucesso!')
    return redirect('login')

@login_required
def manage_tokens(request):
    user = request.user
    context = {
        'tokens': UserToken.objects.filter(user=user),
        'training_files': AITrainingFile.objects.filter(user=user),
        'is_approved': user.profile.is_approved,
        'available_ais': [(ai_type.value, ai_type.value) for ai_type in AIClientType],
        'form': TokenForm(),
        'training_file_form': UserAITrainingFileForm()
    }

    if request.method == 'POST':
        if 'create_token' in request.POST:
            form = TokenForm(request.POST, user=user)
            if form.is_valid():
                if not user.profile.is_approved:
                    messages.error(request, 'Sua conta ainda não foi aprovada pelo administrador.')
                    logger.warning(f"Usuário {user.email} tentou criar token sem aprovação.")
                    return redirect('manage_tokens')
                
                try:
                    token = form.save(commit=False)
                    token.user = user
                    token.save()
                    
                    # Configurar IAs selecionadas
                    selected_ai_types = form.cleaned_data.get('ai_types', [])
                    token.update_ai_configurations(selected_ai_types)
                    
                    logger.info(f"Token '{token.name}' criado para {user.email}")
                    messages.success(request, 'Token criado com sucesso!')
                    return redirect('manage_configurations', token_id=token.id)
                except Exception as e:
                    logger.error(f"Erro ao criar token para {user.email}: {e}")
                    messages.error(request, 'Erro ao criar o token.')
            else:
                context['form'] = form
        
        elif 'upload_training_file' in request.POST:
            training_file_form = UserAITrainingFileForm(request.POST, request.FILES)
            if training_file_form.is_valid():
                try:
                    training_file = training_file_form.save(commit=False)
                    training_file.user = user
                    training_file.save()
                    logger.info(f"Arquivo de treinamento carregado por {user.email}")
                    messages.success(request, 'Arquivo de treinamento carregado com sucesso!')
                    return redirect('manage_tokens')
                except Exception as e:
                    logger.error(f"Erro ao carregar arquivo de treinamento: {e}")
                    messages.error(request, 'Erro ao carregar arquivo.')
            context['training_file_form'] = training_file_form

    return render(request, 'accounts/manage/manage_tokens.html', context)

@login_required
def delete_token(request, token_id):
    user = request.user
    token = get_object_or_404(UserToken, id=token_id, user=user)
    if request.method == 'POST':
        try:
            token.delete()
            logger.info(f"Token '{token.name}' deletado pelo usuário {user.email}.")
            messages.success(request, 'Token deletado com sucesso!')
            return redirect('manage_tokens')
        except Exception as e:
            logger.error(f"Erro ao deletar token para o usuário {user.email}: {e}")
            messages.error(request, 'Erro ao deletar o token. Por favor, tente novamente.')
    return render(request, 'accounts/manage/delete_token.html', {'token': token})

@login_required
def manage_configurations(request, token_id):
    user = request.user
    token = get_object_or_404(UserToken, id=token_id, user=user)
    
    if request.method == 'POST':
        form = UserTokenForm(request.POST, request.FILES, instance=token)
        if form.is_valid():
            try:
                token = form.save()
                logger.info(f"Configurações atualizadas para token '{token.name}'")
                messages.success(request, 'Configurações atualizadas com sucesso!')
                return redirect('manage_configurations', token_id=token.id)
            except Exception as e:
                logger.error(f"Erro ao atualizar configurações: {e}")
                messages.error(request, 'Erro ao salvar as configurações.')
        else:
            logger.warning(f"Formulário inválido: {form.errors}")
            messages.error(request, 'Por favor, corrija os erros no formulário.')
    else:
        form = UserTokenForm(instance=token)

    return render(request, 'accounts/manage/manage_configurations.html', {
        'token': token,
        'form': form,
        'available_ais': [(ai_type.value, ai_type.value) for ai_type in AIClientType]
    })

# Classes de redefinição de senha
class CustomPasswordResetView(auth_views.PasswordResetView):
    email_template_name = 'accounts/registration/password_reset_email.html'
    template_name = 'accounts/registration/password_reset_form.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        current_site = get_current_site(self.request)
        context['domain'] = current_site.domain
        context['site_name'] = current_site.name
        context['protocol'] = 'https' if self.request.is_secure() else 'http'
        return context

    def send_mail(self, *args, **kwargs):
        current_site = get_current_site(self.request)
        context = kwargs.get('context')
        context['domain'] = current_site.domain
        context['site_name'] = current_site.name
        context['protocol'] = 'https' if self.request.is_secure() else 'http'
        try:
            super().send_mail(*args, **kwargs)
            logger.info(f"E-mail de redefinição de senha enviado para {context.get('email')}.")
        except Exception as e:
            logger.error(f"Erro ao enviar e-mail de redefinição de senha: {e}")
            messages.error(self.request, 'Erro ao enviar o e-mail. Por favor, tente novamente.')

# Views de redefinição de senha
def password_reset_view(request):
    return auth_views.PasswordResetView.as_view(template_name='accounts/registration/password_reset_form.html')(request)

def password_reset_done_view(request):
    return auth_views.PasswordResetDoneView.as_view(template_name='accounts/registration/password_reset_done.html')(request)

def password_reset_confirm_view(request, uidb64, token):
    return auth_views.PasswordResetConfirmView.as_view(template_name='accounts/registration/password_reset_confirm.html')(request, uidb64=uidb64, token=token)

def password_reset_complete_view(request):
    return auth_views.PasswordResetCompleteView.as_view(template_name='accounts/registration/password_reset_complete.html')(request)

class CustomConfirmEmailView(ConfirmEmailView):
    def get(self, request, key, *args, **kwargs):
        self.kwargs['key'] = key
        try:
            confirmation = self.get_object()
            confirmation.confirm(request)

            current_site = get_current_site(request)
            user = confirmation.email_address.user
            user.is_active = True
            user.save()
            logger.info(f"Usuário {user.email} ativado após confirmação de email.")

            # Envia notificação ao administrador
            admin_email = settings.ADMIN_EMAIL
            subject = 'Novo Usuário Confirmado'
            message = f'O usuário "{user.email}" confirmou seu email.'
            from_email = settings.DEFAULT_FROM_EMAIL
            recipient_list = [admin_email]

            send_mail(subject, message, from_email, recipient_list)
            logger.info(f"Notificação enviada ao admin sobre o usuário que confirmou email: {user.email}")

            messages.success(request, 'Seu email foi confirmado com sucesso!')
            return redirect('login')
        except Exception as e:
            logger.error(f"Erro ao confirmar email: {e}")
            messages.error(request, 'Erro ao confirmar o email. Por favor, contate o suporte.')
            return redirect('register')


=== accounts/urls.py ===
from django.urls import path
from . import views

urlpatterns = [
    path('register/', views.register_view, name='register'),
    path('login/', views.login_view, name='login'),
    path('logout/', views.logout_view, name='logout'),
    path('manage-tokens/', views.manage_tokens, name='manage_tokens'),
    path('manage-tokens/delete/<uuid:token_id>/', views.delete_token, name='delete_token'),
    path('manage-tokens/<uuid:token_id>/configurations/', views.manage_configurations, name='manage_configurations'),

    # Rotas de redefinição de senha
    path('password_reset/', views.CustomPasswordResetView.as_view(), name='password_reset'),
    path('password_reset/done/', views.password_reset_done_view, name='password_reset_done'),
    path('reset/<uidb64>/<token>/', views.password_reset_confirm_view, name='password_reset_confirm'),
    path('reset/done/', views.password_reset_complete_view, name='password_reset_complete'),
]


=== accounts/apps.py ===
from django.apps import AppConfig

class MyappConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'

    def ready(self):
        import accounts.signals


=== accounts/context_processors.py ===
# myapp/context_processors.py

from django.contrib.sites.models import Site

def site_info(request):
    current_site = Site.objects.get_current()
    return {
        'SITE_NAME': current_site.name,
        'SITE_DOMAIN': current_site.domain,
    }


=== accounts/templates/accounts/registration/password_reset_form.html ===
{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2>Redefinir Senha</h2>
        <form method="post">
            {% csrf_token %}
            {{ form.as_p }}
            <button type="submit" class="btn btn-primary">Enviar Email de Redefinição</button>
        </form>
        <a href="{% url 'login' %}">Voltar para o Login</a>
        {% if messages %}
            <ul>
                {% for message in messages %}
                    <li>{{ message }}</li>
                {% endfor %}
            </ul>
        {% endif %}
    </div>
</div>
{% endblock %}


=== accounts/templates/accounts/registration/password_reset_complete.html ===
{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2>Senha Redefinida com Sucesso</h2>
        <p>Sua senha foi redefinida com sucesso. Você pode agora fazer login com sua nova senha.</p>
        <a href="{% url 'login' %}" class="btn btn-primary">Ir para o Login</a>
    </div>
</div>
{% endblock %}


=== accounts/templates/accounts/registration/password_reset_confirm.html ===
{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2>Confirmar Redefinição de Senha</h2>
        <form method="post">
            {% csrf_token %}
            {{ form.as_p }}
            <button type="submit" class="btn btn-primary">Redefinir Senha</button>
        </form>
    </div>
</div>
{% endblock %}


=== accounts/templates/accounts/registration/register.html ===
{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2 class="mb-4">Registrar</h2>
        <form method="post">
            {% csrf_token %}
            <div class="mb-3">
                {{ form.email.label_tag }}
                {{ form.email }}
                {% for error in form.email.errors %}
                    <small class="text-danger">{{ error }}</small>
                {% endfor %}
            </div>
            <div class="mb-3">
                {{ form.password1.label_tag }}
                {{ form.password1 }}
                {% for error in form.password1.errors %}
                    <small class="text-danger">{{ error }}</small>
                {% endfor %}
            </div>
            <div class="mb-3">
                {{ form.password2.label_tag }}
                {{ form.password2 }}
                {% for error in form.password2.errors %}
                    <small class="text-danger">{{ error }}</small>
                {% endfor %}
            </div>
            <button type="submit" class="btn btn-primary w-100">Registrar</button>
        </form>
        <div class="mt-3 text-center">
            Já tem uma conta? <a href="{% url 'login' %}">Login</a>
        </div>
    </div>
</div>
{% endblock %}


=== accounts/templates/accounts/registration/login.html ===
{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2 class="mb-4">Login</h2>
        {% if form.non_field_errors %}
            <div class="alert alert-danger">
                {% for error in form.non_field_errors %}
                    <p>{{ error }}</p>
                {% endfor %}
            </div>
        {% endif %}
        <form method="post">
            {% csrf_token %}
            <div class="mb-3">
                {{ form.email.label_tag }}
                {{ form.email }}
                {% for error in form.email.errors %}
                    <small class="text-danger">{{ error }}</small>
                {% endfor %}
            </div>
            <div class="mb-3">
                {{ form.password.label_tag }}
                {{ form.password }}
                {% for error in form.password.errors %}
                    <small class="text-danger">{{ error }}</small>
                {% endfor %}
            </div>
            <button type="submit" class="btn btn-primary w-100">Login</button>
        </form>
        <div class="mt-3 text-center">
            <a href="{% url 'register' %}">Criar uma nova conta</a> |
            <a href="{% url 'password_reset' %}">Esqueci minha senha</a>
        </div>
    </div>
</div>
{% endblock %}


=== accounts/templates/accounts/registration/password_reset_email.html ===
{% load i18n %}
{% autoescape off %}
Olá {{ user.get_username }},

Você solicitou uma redefinição de senha para sua conta no site {{ site_name }}.
Por favor, clique no link abaixo para redefinir sua senha:

{{ protocol }}://{{ domain }}{% url 'password_reset_confirm' uidb64=uid token=token %}

Se você não solicitou esta alteração, ignore este email.

Atenciosamente,
Equipe {{ site_name }}
{% endautoescape %}


=== accounts/templates/accounts/registration/password_reset_done.html ===
{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2>Email de Redefinição Enviado</h2>
        <p>Por favor, verifique seu email para obter instruções de como redefinir sua senha.</p>
        <a href="{% url 'login' %}" class="btn btn-primary">Voltar para o Login</a>
    </div>
</div>
{% endblock %}


=== accounts/templates/accounts/manage/manage_tokens.html ===
{% extends 'base.html' %}
{% load custom_tags %}
{% load ai_config_tags %}

{% block content %}
<h2 class="mb-4">Gerenciador</h2>

<ul class="nav nav-tabs" id="manageTabs" role="tablist">
    <li class="nav-item" role="presentation">
        <button class="nav-link active" id="tokens-tab" data-bs-toggle="tab" data-bs-target="#tokens" type="button" role="tab" aria-controls="tokens" aria-selected="true">Tokens</button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="training-files-tab" data-bs-toggle="tab" data-bs-target="#training-files" type="button" role="tab" aria-controls="training-files" aria-selected="false">Arquivos de Treinamento</button>
    </li>
</ul>
<div class="tab-content" id="manageTabsContent">
    <!-- Tokens Tab -->
    <div class="tab-pane fade show active" id="tokens" role="tabpanel" aria-labelledby="tokens-tab">
        <div class="mt-4">
            {% if is_approved %}
                <h4>Criar Novo Token</h4>
                <form method="post" class="mb-4">
                    {% csrf_token %}
                    <input type="hidden" name="create_token" value="1">
                    <div class="mb-3">
                        {{ form.name.label_tag }}
                        {{ form.name }}
                        {% for error in form.name.errors %}
                            <small class="text-danger">{{ error }}</small>
                        {% endfor %}
                    </div>
                    <button type="submit" class="btn btn-success">Criar Token</button>
                </form>
            {% else %}
                <div class="alert alert-warning">
                    Sua conta ainda não foi aprovada pelo administrador. Você não pode gerar novos tokens até que sua conta seja aprovada.
                </div>
            {% endif %}

            <h4>Tokens Existentes</h4>
            {% if tokens %}
                <div class="table-responsive">
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Nome</th>
                                <th>Chave</th>
                                <th>Data de Criação</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for token in tokens %}
                                <tr>
                                    <td>
                                        <a href="{% url 'manage_configurations' token.id %}">{{ token.name }}</a>
                                    </td>
                                    <td>{{ token.key }}</td>
                                    <td>{{ token.created|date:"d/m/Y H:i" }}</td>
                                </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            {% else %}
                <div class="alert alert-info">
                    Você não possui tokens.
                </div>
            {% endif %}
        </div>
    </div>

    <!-- Arquivos de Treinamento Tab -->
    <div class="tab-pane fade" id="training-files" role="tabpanel" aria-labelledby="training-files-tab">
        <div class="mt-4">
            <h4>Upload de Arquivo de Treinamento</h4>
            <form method="post" enctype="multipart/form-data" class="mb-4">
                {% csrf_token %}
                <input type="hidden" name="upload_training_file" value="1">
                <div class="mb-3">
                    {{ training_file_form.file.label_tag }}
                    {{ training_file_form.file }}
                    {% for error in training_file_form.file.errors %}
                        <small class="text-danger">{{ error }}</small>
                    {% endfor %}
                </div>
                <button type="submit" class="btn btn-primary">Upload Arquivo</button>
            </form>
            <div class="mb-3">
                <a href="{% url 'ai_config:create_training_file'%}" class="btn btn-primary">Criar Novo Arquivo de Treinamento</a>
            </div>

            <h4>Arquivos de Treinamento</h4>
            {% if training_files %}
                <div class="table-responsive">
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Nome do Arquivo</th>
                                <th>Data de Upload</th>
                                <th>Ações</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for training_file in training_files %}
                                <tr>
                                    <td>{{ training_file.file.name|basename }}</td>
                                    <td>{{ training_file.uploaded_at|date:"d/m/Y H:i" }}</td>
                                    <td>
                                        <a href="{% url 'ai_config:edit_training_file' training_file.id %}" class="btn btn-primary btn-sm">Editar</a>
                                        <a href="{% url 'ai_config:download_training_file' training_file.id %}" class="btn btn-success btn-sm">Baixar</a>
                                        <form action="{% url 'ai_config:delete_training_file' training_file.id %}" method="post" style="display:inline;">
                                            {% csrf_token %}
                                            <button type="submit" class="btn btn-danger btn-sm" onclick="return confirm('Tem certeza que deseja excluir este arquivo?');">Excluir</button>
                                        </form>
                                    </td>
                                </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            {% else %}
                <div class="alert alert-info">
                    Você não possui arquivos de treinamento.
                </div>
            {% endif %}
        </div>
    </div>
</div>
{% endblock %}


=== accounts/templates/accounts/manage/manage_configurations.html ===
<!-- accounts/templates/accounts/manage/manage_configurations.html -->
{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-8">
        <h2 class="mb-4">Configurações para o Token "{{ token.name }}"</h2>
        
        <!-- Formulário de Configurações -->
        <form method="post" enctype="multipart/form-data" class="mb-4">
            {% csrf_token %}
            {{ form.as_p }}
            <button type="submit" class="btn btn-primary">Salvar Configurações</button>
        </form>
        
        <!-- Botões de Ação Integrados -->
        <div class="d-flex flex-wrap justify-content-start gap-2">
            <a href="{% url 'ai_config:manage_ai_configurations' token.id %}" class="btn btn-info">Configurar IA</a>
            <a href="{% url 'ai_config:manage_token_configurations' token.id %}" class="btn btn-secondary">Configurar Prompt</a>
            <a href="{% url 'ai_config:manage_training_configurations' token.id %}" class="btn btn-warning">Parâmetros de Treinamento</a>
            <a href="{% url 'ai_config:train_ai' token.id %}" class="btn btn-danger">Treinar IA</a>
            <form method="post" action="{% url 'delete_token' token.id %}" class="d-inline">
                {% csrf_token %}
                <button type="submit" class="btn btn-danger" onclick="return confirm('Tem certeza que deseja deletar este token?');">Excluir Token</button>
            </form>
        </div>
        
        <!-- Botão para Voltar -->
        <div class="mt-3">
            <a href="{% url 'manage_tokens' %}" class="btn btn-outline-secondary">Voltar para Gerenciar Tokens</a>
        </div>
    </div>
</div>
{% endblock %}


=== accounts/templates/accounts/manage/delete_token.html ===
{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2>Deletar Token</h2>
        <p>Tem certeza que deseja deletar o token "<strong>{{ token.name }}</strong>"?</p>
        <form method="post">
            {% csrf_token %}
            <button type="submit" class="btn btn-danger">Confirmar Deleção</button>
            <a href="{% url 'manage_tokens' %}" class="btn btn-secondary">Cancelar</a>
        </form>
    </div>
</div>
{% endblock %}


=== accounts/templates/accounts/emails/email_confirm.html ===
{% extends "base.html" %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2>Confirmação de Email</h2>
        <p>Seu email foi confirmado com sucesso! Agora você pode fazer login na sua conta.</p>
        <a href="{% url 'login' %}" class="btn btn-primary">Ir para o Login</a>
    </div>
</div>
{% endblock %}


=== accounts/templates/accounts/emails/email_confirmation_message.txt ===
{% load account %}
Olá do site {{ current_site.name }}!

Você está recebendo esta mensagem porque o usuário {{ user.email }} utilizou este e-mail para se cadastrar no site {{ current_site.name }}.

Para confirmar que isso está correto, clique em {{ activate_url }}

Obrigado por usar o site {{ current_site.name }}!
{{ current_site.name }}


=== accounts/templates/accounts/emails/email_confirm_done.html ===
{% extends "base.html" %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2>Confirmação de Email</h2>
        <p>Seu email foi confirmado com sucesso! Agora você pode fazer login na sua conta.</p>
        <a href="{% url 'login' %}" class="btn btn-primary">Ir para o Login</a>
    </div>
</div>
{% endblock %}


=== accounts/templates/accounts/emails/email_confirm_failed.html ===
{% extends "base.html" %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2>Confirmação de Email</h2>
        <p>Seu email foi confirmado com sucesso! Agora você pode fazer login na sua conta.</p>
        <a href="{% url 'login' %}" class="btn btn-primary">Ir para o Login</a>
    </div>
</div>
{% endblock %}


=== accounts/admin.py ===
import bleach
from django import forms
from django.conf import settings
from django.contrib import admin
from .models import Profile, UserToken

from tinymce.widgets import TinyMCE

import os
import logging

logger = logging.getLogger(__name__)


class ProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'is_approved')
    list_editable = ('is_approved',)


class UserTokenAdmin(admin.ModelAdmin):
    form = forms.ModelForm 
    list_display = ('name', 'key', 'user', 'created')
    search_fields = ('name', 'key', 'user__email')


admin.site.register(Profile, ProfileAdmin)
admin.site.register(UserToken, UserTokenAdmin)


=== accounts/signals.py ===
# myapp/signals.py

import logging
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from .models import Profile
from django.core.mail import send_mail
from django.conf import settings

logger = logging.getLogger(__name__)

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        Profile.objects.create(user=instance)
        logger.info(f"Perfil criado para o usuário: {instance.email}")

@receiver(post_save, sender=Profile)
def handle_user_approval(sender, instance, created, **kwargs):
    if not created:
        if instance.is_approved:
            user = instance.user
            user.is_active = True  # Ativa a conta após aprovação
            user.save()
            subject = 'Sua conta foi aprovada!'
            message = 'Olá, sua conta foi aprovada pelo administrador e agora você pode fazer login.'
            from_email = settings.DEFAULT_FROM_EMAIL
            recipient_list = [user.email]
            try:
                send_mail(subject, message, from_email, recipient_list)
                logger.info(f"Notificação enviada ao usuário aprovado: {user.email}")
            except Exception as e:
                logger.error(f"Erro ao enviar e-mail de aprovação para o usuário {user.email}: {e}")
        else:
            admin_email = settings.ADMIN_EMAIL
            subject = 'Novo Usuário Registrado para Aprovação'
            message = f'O usuário "{instance.user.email}" se registrou e está aguardando aprovação.'
            from_email = settings.DEFAULT_FROM_EMAIL
            recipient_list = [admin_email]
            try:
                send_mail(subject, message, from_email, recipient_list)
                logger.info(f"Notificação enviada ao admin sobre o novo usuário: {instance.user.email}")
            except Exception as e:
                logger.error(f"Erro ao enviar e-mail para o admin: {e}")


=== accounts/authentication.py ===
from rest_framework.authentication import TokenAuthentication
from rest_framework import exceptions
from .models import UserToken

class CustomTokenAuthentication(TokenAuthentication):
    keyword = 'Token'

    def authenticate_credentials(self, key):
        try:
            token = UserToken.objects.get(key=key)
        except UserToken.DoesNotExist:
            raise exceptions.AuthenticationFailed('Token inválido.')

        if not token.user.is_active:
            raise exceptions.AuthenticationFailed('Usuário inativo ou token inválido.')

        return (token.user, token)


=== accounts/models.py ===
import uuid
from django.db import models
from django.contrib.auth.models import User

class Profile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    is_approved = models.BooleanField(default=False)

    def __str__(self):
        return f"{self.user.email} Profile"

class UserToken(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, related_name='tokens', on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    key = models.CharField(max_length=40, unique=True)
    created = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ('user', 'name')

    def save(self, *args, **kwargs):
        if not self.key:
            self.key = self.generate_unique_key()
        super().save(*args, **kwargs)

    def generate_unique_key(self):
        key = uuid.uuid4().hex
        while UserToken.objects.filter(key=key).exists():
            key = uuid.uuid4().hex
        return key

    def __str__(self):
        return f"{self.name} - {self.key}"

=== accounts/forms.py ===
# accounts/forms.py

import json
import bleach
from django import forms
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth import get_user_model, authenticate
from allauth.account.models import EmailAddress

from tinymce.widgets import TinyMCE

from .models import UserToken
from api.constants import AIClientType

ALLOWED_TAGS = bleach.sanitizer.ALLOWED_TAGS.union({
    'p', 'br', 'strong', 'em', 'ul', 'ol', 'li',
    'table', 'tr', 'td', 'th', 'a', 'div', 
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'section'
})
ALLOWED_ATTRIBUTES = {
    '*': ['class', 'style'],
    'a': ['href', 'title'],
    'img': ['src', 'alt', 'title', 'width', 'height'],
}

User = get_user_model()


class CustomUserCreationForm(UserCreationForm):
    email = forms.EmailField(
        required=True,
        widget=forms.EmailInput(attrs={'class': 'form-control', 'placeholder': 'Email'})
    )
    password1 = forms.CharField(
        label='Senha',
        widget=forms.PasswordInput(attrs={'class': 'form-control', 'placeholder': 'Senha'})
    )
    password2 = forms.CharField(
        label='Confirme a Senha',
        widget=forms.PasswordInput(attrs={'class': 'form-control', 'placeholder': 'Confirme a Senha'})
    )

    class Meta:
        model = User
        fields = ('email', 'password1', 'password2')

    def save(self, commit=True):
        user = super().save(commit=False)
        user.email = self.cleaned_data['email']
        user.username = self.cleaned_data['email']
        user.is_active = False  # Desativa a conta até a confirmação do email
        if commit:
            user.save()
        return user


class TokenForm(forms.ModelForm):
    class Meta:
        model = UserToken
        fields = ['name']
        widgets = {
            'name': forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'Nome do Token'})
        }

    def __init__(self, *args, **kwargs):
        self.user = kwargs.pop('user', None)
        super(TokenForm, self).__init__(*args, **kwargs)
        # Adicionar choices para tipos de IA disponíveis
        self.fields['ai_types'] = forms.MultipleChoiceField(
            choices=[(ai_type.value, ai_type.value) for ai_type in AIClientType],
            required=False,
            widget=forms.CheckboxSelectMultiple
        )

    def clean_name(self):
        name = self.cleaned_data.get('name')
        if UserToken.objects.filter(user=self.user, name=name).exists():
            raise forms.ValidationError('Já existe um token com esse nome.')
        return name


class EmailAuthenticationForm(forms.Form):
    email = forms.EmailField(
        label='Email',
        max_length=254,
        widget=forms.EmailInput(attrs={'class': 'form-control', 'placeholder': 'Email'})
    )
    password = forms.CharField(
        label='Senha',
        widget=forms.PasswordInput(attrs={'class': 'form-control', 'placeholder': 'Senha'})
    )

    def __init__(self, request=None, *args, **kwargs):
        self.request = request
        super().__init__(*args, **kwargs)

    def clean(self):
        email = self.cleaned_data.get('email')
        password = self.cleaned_data.get('password')

        if email and password:
            self.user = authenticate(self.request, username=email, password=password)
            if self.user is not None:
                # Verifica se o email foi confirmado
                email_address = EmailAddress.objects.filter(user=self.user, email=self.user.email).first()
                if email_address and not email_address.verified:
                    raise forms.ValidationError('Seu email ainda não foi confirmado.')

                # Verifica se a conta está ativa
                if not self.user.is_active:
                    raise forms.ValidationError('Sua conta está inativa.')
            else:
                raise forms.ValidationError('Email ou senha inválidos.')
        else:
            raise forms.ValidationError('Por favor, preencha todos os campos.')

        return self.cleaned_data
    
    def get_user(self):
        return self.user

class UserTokenForm(forms.ModelForm):
    class Meta:
        model = UserToken
        fields = ['name']
        widgets = {
            'name': forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'Nome do Token'})
        }

    def clean_name(self):
        name = self.cleaned_data.get('name')
        if UserToken.objects.filter(user=self.instance.user, name=name).exclude(id=self.instance.id).exists():
            raise forms.ValidationError('Já existe um token com esse nome.')
        return name

    def save(self, commit=True):
        token = super().save(commit=False)
        if commit:
            token.save()
        return token

=== accounts/templatetags/custom_tags.py ===
from django import template
import os

register = template.Library()

@register.filter
def basename(value):
    return os.path.basename(value)


=== manage.py ===
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


=== ai_config/utils.py ===
from .models import AIClientConfiguration
from api.utils.clientsIA import ChatGPTClient, GeminiClient, Claude3Client, PerplexityClient
from api.constants import AI_CLIENT_MAPPING, AIClientType
import concurrent.futures
import logging

logger = logging.getLogger(__name__)

# Mapeamento direto de strings para classes de cliente
CLIENT_CLASSES = {
    AIClientType.CHATGPT.value: ChatGPTClient,
    AIClientType.GEMINI.value: GeminiClient,
    AIClientType.CLAUDE3.value: Claude3Client,
    AIClientType.PERPLEXITY.value: PerplexityClient,
}

def perform_training(user, token, selected_ias=None):
    results = {}

    # Obter as AIClientConfigurations para o token, filtrando pelas IAs selecionadas
    if selected_ias:
        ai_client_configs = AIClientConfiguration.objects.filter(
            token=token,
            enabled=True,
            ai_client__api_client_class__in=selected_ias
        )
    else:
        ai_client_configs = AIClientConfiguration.objects.filter(
            token=token,
            enabled=True
        )

    def train_ai(ai_client_config):
        ai_client_name = ai_client_config.ai_client.api_client_class
        ai_client_cls = CLIENT_CLASSES.get(ai_client_name)

        if not ai_client_cls:
            return ai_client_name, f"Erro: Cliente de IA '{ai_client_name}' não encontrado no mapeamento."

        # Verificar se a IA pode ser treinada
        if not ai_client_cls.can_train:
            return ai_client_name, "Erro: Esta IA não suporta treinamento."

        # Obter o arquivo de treinamento do TokenAIConfiguration
        token_ai_config = token.ai_configuration
        training_file = token_ai_config.training_file
        if not training_file:
            return ai_client_name, "Erro: Arquivo de treinamento não selecionado para o token."

        try:
            result = perform_training_for_single_ai(user, token, ai_client_config, training_file)
            return ai_client_name, result[1]
        except Exception as e:
            logger.error(f"Erro ao treinar {ai_client_name} para token {token.name}: {e}")
            return ai_client_name, f"Erro: {str(e)}"

    # Usar ThreadPoolExecutor para treinar as IAs em paralelo
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = {
            executor.submit(train_ai, ai_client_config): ai_client_config.ai_client.api_client_class
            for ai_client_config in ai_client_configs
        }

        for future in concurrent.futures.as_completed(futures):
            ai_client_name = futures[future]
            try:
                ai_client_name_result, result = future.result()
                results[ai_client_name_result] = result
            except Exception as e:
                logger.error(f"Erro inesperado ao treinar {ai_client_name} para token {token.name}: {e}")
                results[ai_client_name] = f"Erro: {str(e)}"

    return results

def perform_training_for_single_ai(user, token, ai_client_config, training_file):
    ai_client_name = ai_client_config.ai_client.api_client_class
    ai_client_cls = CLIENT_CLASSES.get(ai_client_name)

    if not ai_client_cls:
        return ai_client_name, f"Erro: Cliente de IA '{ai_client_name}' não encontrado no mapeamento."

    # Verificar se a IA pode ser treinada
    if not ai_client_cls.can_train:
        return ai_client_name, "Erro: Esta IA não suporta treinamento."

    try:
        parametersAITraining = ai_client_config.training.training_parameters

        client = ai_client_cls({
            'api_key': ai_client_config.ai_client.api_key,
            'model_name': ai_client_config.model_name,
            'configurations': ai_client_config.configurations,
            'base_instruction': '',
            'prompt': '',
            'responses': ''
        })
        
        # Usar o arquivo de treinamento
        trained_model_name = client.train(training_file.file, parametersAITraining)
        ai_client_config.training.trained_model_name = trained_model_name
        ai_client_config.training.save()

        logger.info(
            f"IA {ai_client_name} treinada com sucesso para token {token.name}. Modelo: {trained_model_name}"
        )
        return ai_client_name, f"Modelo treinado: {trained_model_name}"
    except Exception as e:
        logger.error(f"Erro ao treinar {ai_client_name} para token {token.name}: {e}")
        return ai_client_name, f"Erro: {str(e)}"

=== ai_config/views.py ===
import logging
import tempfile
import json
import os
import uuid

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.http import FileResponse, JsonResponse
from django.forms import formset_factory
from django.views.decorators.http import require_POST
from django.core.files import File
from django.conf import settings
from django.utils import timezone
from datetime import timedelta

from accounts.models import UserToken
from api.constants import AIClientType
from .utils import CLIENT_CLASSES

from .forms import (
    AIClientConfigurationForm, 
    TokenAIConfigurationForm, 
    UserAITrainingFileForm, 
    AIClientTrainingForm,
    TrainAIForm,
    TrainingExampleForm,
    AITrainingFileNameForm,
    TrainingCaptureForm)
from .models import (
    AIClientGlobalConfiguration,
    AIClientConfiguration, 
    TokenAIConfiguration, 
    AIClientTraining,
    AITrainingFile,
    TrainingCapture)
from .utils import perform_training

# Configuração do logger
logger = logging.getLogger(__name__)

@login_required
def manage_ai_configurations(request, token_id):
    user = request.user
    token = get_object_or_404(UserToken, id=token_id, user=user)

    forms = []
    for ai_type in AIClientType:
        ai_client_name = ai_type.value
        try:
            ai_client = AIClientGlobalConfiguration.objects.get(api_client_class=ai_client_name)
            ai_client_config = AIClientConfiguration.objects.get(token=token, ai_client=ai_client)
        except AIClientConfiguration.DoesNotExist:
            ai_client_config = AIClientConfiguration(token=token, ai_client=ai_client, enabled=False)
        except AIClientGlobalConfiguration.DoesNotExist:
            logger.error(f"AIClient com api_client_class='{ai_client_name}' não encontrado.")
            messages.error(request, f"Cliente de IA '{ai_client_name}' não configurado. Entre em contato com o administrador.")
            continue

        # Prefix para evitar conflitos de campos nos formulários
        form = AIClientConfigurationForm(instance=ai_client_config, prefix=ai_client_name)
        forms.append({'ai_client': ai_client_name, 'form': form})

    if request.method == 'POST':
        success = True
        for ai_form in forms:
            form = AIClientConfigurationForm(request.POST, request.FILES, instance=ai_form['form'].instance, prefix=ai_form['ai_client'])
            if form.is_valid():
                try:
                    form.save()
                except Exception as e:
                    success = False
                    logger.error(f"Erro ao salvar configurações para {ai_form['ai_client']}: {e}")
                    messages.error(request, f"Erro ao salvar configurações para {ai_form['ai_client']}. Por favor, tente novamente.")
            else:
                success = False
                logger.warning(f"Formulário inválido para {ai_form['ai_client']}: {form.errors}")
                messages.error(request, f"Por favor, corrija os erros nas configurações para {ai_form['ai_client']}.")

        if success:
            messages.success(request, "Configurações de IA salvas com sucesso!")
            return redirect('manage_configurations', token_id=token.id)  # Redireciona para a configuração do token

    context = {'token': token, 'forms': forms}
    return render(request, 'ai_config/manage_ai_configurations.html', context)

@login_required
def manage_token_configurations(request, token_id):
    user = request.user
    token = get_object_or_404(UserToken, id=token_id, user=user)

    # Obter ou criar a configuração de IA específica do token
    try:
        token_ai_config = token.ai_configuration
    except TokenAIConfiguration.DoesNotExist:
        token_ai_config = TokenAIConfiguration.objects.create(token=token)

    if request.method == 'POST':
        form = TokenAIConfigurationForm(request.POST, request.FILES, instance=token_ai_config, user=user)
        if form.is_valid():
            try:
                form.save()
                logger.info(f"Configuração TokenAI atualizada para o token '{token.name}' pelo usuário {user.email}.")
                messages.success(request, 'Configurações TokenAI atualizadas com sucesso!')
                return redirect('manage_configurations', token_id=token.id)
            except Exception as e:
                logger.error(f"Erro ao salvar TokenAIConfiguration para o token '{token.name}': {e}")
                messages.error(request, 'Erro ao salvar as configurações TokenAI. Por favor, tente novamente.')
        else:
            logger.warning(f"Formulário TokenAIConfiguration inválido para o token '{token.name}': {form.errors}")
            messages.error(request, 'Por favor, corrija os erros no formulário TokenAI.')
    else:
        form = TokenAIConfigurationForm(instance=token_ai_config, user=user)

    context = {'token': token, 'form': form}
    return render(request, 'ai_config/manage_token_configurations.html', context)

@login_required
def manage_training_configurations(request, token_id):
    user = request.user
    token = get_object_or_404(UserToken, id=token_id, user=user)

    ai_client_configs = AIClientConfiguration.objects.filter(token=token)

    forms = []
    for ai_client_config in ai_client_configs:
        ai_client_name = ai_client_config.ai_client.api_client_class
        client_class = CLIENT_CLASSES.get(ai_client_name)
        
        if client_class and client_class.can_train:
            try:
                ai_client_training = AIClientTraining.objects.get(ai_client_configuration=ai_client_config)
            except AIClientTraining.DoesNotExist:
                ai_client_training = AIClientTraining(ai_client_configuration=ai_client_config)

            form = AIClientTrainingForm(instance=ai_client_training, prefix=ai_client_name)
            forms.append({'ai_client': ai_client_name, 'form': form})

    if request.method == 'POST':
        success = True
        for ai_form in forms:
            form = AIClientTrainingForm(request.POST, instance=ai_form['form'].instance, prefix=ai_form['ai_client'])
            if form.is_valid():
                try:
                    form.save()
                except Exception as e:
                    success = False
                    logger.error(f"Erro ao salvar parâmetros de treinamento para {ai_form['ai_client']}: {e}")
                    messages.error(request, f"Erro ao salvar parâmetros de treinamento para {ai_form['ai_client']}. Por favor, tente novamente.")
            else:
                success = False
                logger.warning(f"Formulário inválido para {ai_form['ai_client']}: {form.errors}")
                messages.error(request, f"Por favor, corrija os erros nos parâmetros de treinamento para {ai_form['ai_client']}.")

        if success:
            messages.success(request, "Parâmetros de treinamento salvos com sucesso!")
            return redirect('manage_configurations', token_id=token.id)  # Redireciona para a configuração do token

    context = {'token': token, 'forms': forms}
    return render(request, 'ai_config/manage_training_configurations.html', context)

@login_required
def train_ai(request, token_id):
    user = request.user
    token = get_object_or_404(UserToken, id=token_id, user=user)

    # Obter as configurações de IA habilitadas para o token
    ai_client_configs = AIClientConfiguration.objects.filter(token=token, enabled=True)

    # Listas para IAs treináveis e não treináveis
    ai_clients_trainable = []
    ai_clients_not_trainable = []

    # Obter as classes de IA correspondentes
    for ai_client_config in ai_client_configs:
        ai_client_name = ai_client_config.ai_client.api_client_class
        client_class = CLIENT_CLASSES.get(ai_client_name)
        if client_class:
            if client_class.can_train:
                ai_clients_trainable.append({
                    'name': ai_client_name,
                    'trained_model_name': ai_client_config.training.trained_model_name if hasattr(ai_client_config, 'training') else None
                })
            else:
                ai_clients_not_trainable.append(ai_client_name)

    logger.debug(f"AI Clients treináveis: {[cls['name'] for cls in ai_clients_trainable]}")
    logger.debug(f"AI Clients não treináveis: {ai_clients_not_trainable}")

    if request.method == 'POST':
        form = TrainAIForm(request.POST, ai_clients=[client['name'] for client in ai_clients_trainable])
        if not form.is_valid():
            messages.error(request, "Por favor, corrija os erros no formulário.")
            return redirect('ai_config:train_ai', token_id=token.id)

        selected_ias = form.cleaned_data['ai_clients_to_train']

        if not selected_ias:
            messages.warning(request, "Nenhuma IA selecionada.")
            return redirect('ai_config:train_ai', token_id=token.id)

        action = request.POST.get('action')

        if action == 'train':
            # Usar a função perform_training com as IAs selecionadas
            results = perform_training(user, token, selected_ias=selected_ias)
            for ai_name, res in results.items():
                messages.info(request, f"{ai_name}: {res}")
            return redirect('ai_config:train_ai', token_id=token.id)
        elif action == 'remove_model':
            # Remover modelos treinados das IAs selecionadas
            for ai_client_name in selected_ias:
                try:
                    # Obter a configuração global do cliente de IA
                    ai_client = AIClientGlobalConfiguration.objects.get(api_client_class=ai_client_name)
                except AIClientGlobalConfiguration.DoesNotExist:
                    messages.error(request, f"Cliente de IA '{ai_client_name}' não encontrado.")
                    continue

                try:
                    # Obter a configuração específica do cliente de IA para o token
                    ai_client_config = ai_client_configs.get(ai_client__api_client_class=ai_client_name)
                    ai_training = ai_client_config.training

                    if ai_training.trained_model_name:
                        ai_training.trained_model_name = None  # ou '' dependendo da preferência
                        ai_training.save()
                        messages.success(request, f"Modelo treinado para '{ai_client_name}' removido com sucesso.")
                    else:
                        messages.info(request, f"Nenhum modelo treinado encontrado para '{ai_client_name}'.")
                except AIClientConfiguration.DoesNotExist:
                    messages.error(request, f"Configuração de IA para '{ai_client_name}' não encontrada.")
                except Exception as e:
                    logger.error(f"Erro ao remover o modelo treinado para {ai_client_name}: {e}")
                    messages.error(request, f"Erro ao remover o modelo treinado para '{ai_client_name}'. Por favor, tente novamente.")

            return redirect('ai_config:train_ai', token_id=token.id)
    else:
        form = TrainAIForm(ai_clients=[client['name'] for client in ai_clients_trainable])

    context = {
        'token': token,
        'form': form,
        'ai_clients_not_trainable': ai_clients_not_trainable,
        'ai_clients_trainable_details': ai_clients_trainable,
    }
    return render(request, 'ai_config/train_ai.html', context)

@login_required
def upload_training_file(request, token_id):
    user = request.user
    token = get_object_or_404(UserToken, id=token_id, user=user)

    if request.method == 'POST':
        form = UserAITrainingFileForm(request.POST, request.FILES)
        if form.is_valid():
            training_file = form.save(commit=False)
            training_file.user = user
            training_file.save()
            logger.info(f"Arquivo de treinamento carregado pelo usuário {user.email}.")
            messages.success(request, 'Arquivo de treinamento carregado com sucesso!')
            return redirect('manage_tokens')
        else:
            logger.warning(f"Formulário de upload de arquivo de treinamento inválido: {form.errors}")
            messages.error(request, 'Por favor, corrija os erros no formulário.')
    else:
        form = UserAITrainingFileForm()

    context = {'token': token, 'form': form}
    return render(request, 'ai_config/upload_training_file.html', context)

TrainingExampleFormSetFactory = formset_factory(
    TrainingExampleForm,
    can_delete=True,
    extra=0
)

@login_required
def create_or_edit_training_file(request, file_id=None):
    user = request.user
    training_file = None
    initial_data = []
    initial_name = ''

    if file_id:
        # Editando um arquivo existente
        training_file = get_object_or_404(AITrainingFile, id=file_id, user=user)
        initial_name = training_file.name
        try:
            with training_file.file.open('rb') as f:
                content = f.read().decode('utf-8')
                data = json.loads(content)
                for example in data:
                    system_message = example.get('system_message', '').strip()
                    user_message = example.get('user_message', '').strip()
                    response = example.get('response', '').strip()
                    initial_data.append({
                        'system_message': system_message,
                        'user_message': user_message,
                        'response': response
                    })
        except json.JSONDecodeError as e:
            logger.error(f"Erro ao decodificar JSON no arquivo de treinamento: {e}")
            messages.error(request, 'O arquivo de treinamento está corrompido ou não está no formato JSON válido.')
            return redirect('manage_tokens')
        except Exception as e:
            logger.error(f"Erro ao abrir o arquivo de treinamento: {e}")
            messages.error(request, 'Erro ao abrir o arquivo de treinamento.')
            return redirect('manage_tokens')
        
        # Formset para edição - sem formulários extras
        TrainingExampleFormSetEdit = formset_factory(
            TrainingExampleForm,
            can_delete=True,
            extra=0
        )
        formset = TrainingExampleFormSetEdit(initial=initial_data, prefix='form')
        name_form = AITrainingFileNameForm(initial={'name': initial_name, 'token': training_file.user.id}, prefix='name')
    else:
        # Criando um novo arquivo - inicializa com 1 formulário
        TrainingExampleFormSetCreate = formset_factory(
            TrainingExampleForm,
            can_delete=True,
            extra=1
        )
        formset = TrainingExampleFormSetCreate(request.POST or None, prefix='form')
        name_form = AITrainingFileNameForm(prefix='name')
                                   
    if request.method == 'POST':
        name_form = AITrainingFileNameForm(request.POST, prefix='name')
        formset = TrainingExampleFormSetFactory(request.POST, prefix='form')
        
        if name_form.is_valid() and formset.is_valid():
            name = name_form.cleaned_data['name']
            examples = []
            for form in formset:
                if form.cleaned_data and not form.cleaned_data.get('DELETE', False):
                    system_message = form.cleaned_data.get('system_message', '').strip()
                    user_message = form.cleaned_data.get('user_message', '').strip()
                    response = form.cleaned_data.get('response', '').strip()
                    example = {
                        'system_message': system_message,
                        'user_message': user_message,
                        'response': response
                    }
                    examples.append(example)
            
            if not examples:
                messages.error(request, 'Por favor, adicione pelo menos um exemplo.')
            else:
                # Criar um arquivo temporário com os exemplos
                with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.json') as temp_file:
                    json.dump(examples, temp_file, ensure_ascii=False, indent=4)
                    temp_file_path = temp_file.name
                
                try:
                    if training_file:
                        # Atualizar o arquivo existente
                        existing_file_name = os.path.basename(training_file.file.name)
                        with open(temp_file_path, 'rb') as f:
                            training_file.file.save(existing_file_name, File(f), save=True)
                        # Atualizar o nome, se necessário
                        if training_file.name != name:
                            training_file.name = name
                            training_file.save()
                        messages.success(request, 'Arquivo de treinamento atualizado com sucesso!')
                        if 'save_and_continue' in request.POST:
                            return redirect('ai_config:edit_training_file', file_id=training_file.id)
                        else:
                            return redirect('manage_tokens')
                    else:
                        # Verificar se o nome já existe para o usuário
                        if AITrainingFile.objects.filter(user=user, name=name).exists():
                            messages.error(request, 'Você já possui um arquivo de treinamento com este nome.')
                            os.remove(temp_file_path)
                            return render(request, 'ai_config/create_training_file.html', {'formset': formset, 'name_form': name_form, 'capture_form': TrainingCaptureForm(prefix='capture', user=user)})
                        
                        # Gerar um nome de arquivo único
                        unique_filename = f"{name}_{uuid.uuid4().hex}.json"
                        with open(temp_file_path, 'rb') as f:
                            training_file = AITrainingFile.objects.create(
                                user=user,
                                name=name,
                                file=File(f, name=unique_filename)
                            )
                        messages.success(request, 'Arquivo de treinamento criado com sucesso!')
                        if 'save_and_continue' in request.POST:
                            return redirect('ai_config:edit_training_file', file_id=training_file.id)
                        else:
                            return redirect('manage_tokens')
                except Exception as e:
                    logger.error(f"Erro ao salvar o arquivo de treinamento: {e}")
                    messages.error(request, 'Erro ao salvar o arquivo de treinamento.')
                finally:
                    # Remover o arquivo temporário
                    if os.path.exists(temp_file_path):
                        os.remove(temp_file_path)
        else:
            if not name_form.is_valid():
                messages.error(request, 'Por favor, corrija os erros no campo de nome.')
            if not formset.is_valid():
                messages.error(request, 'Por favor, corrija os erros nos exemplos.')
    else:
        # GET request
        pass

    # Obter a captura ativa para o usuário atual
    active_capture = TrainingCapture.objects.filter(token__user=user, is_active=True).first()
    if active_capture:
        # Verificar se last_activity tem mais de 1 minuto
        time_difference = timezone.now() - active_capture.last_activity
        if time_difference > timedelta(minutes=1):
            # Desativar a captura
            active_capture.is_active = False
            active_capture.save()
            active_capture = None  # Não há captura ativa após desativar
            # Inicializar o formulário de captura sem instância
            capture_form = TrainingCaptureForm(prefix='capture', user=user)
        else:
            # Preencher o formulário de captura com a captura ativa
            capture_form = TrainingCaptureForm(instance=active_capture, prefix='capture', user=user)
    else:
        # Inicializar o formulário de captura sem instância
        capture_form = TrainingCaptureForm(prefix='capture', user=user)

    context = {
        'formset': formset,
        'name_form': name_form,
        'training_file': training_file,
        'capture_form': capture_form,
        'active_capture': active_capture
    }
    return render(request, 'ai_config/create_training_file.html', context)

@login_required
def download_training_file(request, file_id):
    user = request.user
    training_file = get_object_or_404(AITrainingFile, id=file_id, user=user)
    response = FileResponse(training_file.file.open('rb'), as_attachment=True, filename=training_file.file.name)
    return response

@login_required
def delete_training_file(request, file_id):
    user = request.user
    training_file = get_object_or_404(AITrainingFile, id=file_id, user=user)
    if request.method == 'POST':
        file_path = training_file.file.path
        training_file.file.delete()
        logger.debug(f"Arquivo físico deletado: {file_path}")
        training_file.delete()
        messages.success(request, 'Arquivo de treinamento excluído com sucesso!')
        return redirect('manage_tokens')
    else:
        context = {'training_file': training_file}
        return render(request, 'ai_config/confirm_delete_training_file.html', context)

@login_required
@require_POST
def toggle_capture(request):
    token_id = request.POST.get('token_id')
    ai_client_name = request.POST.get('ai_client_id')
    action = request.POST.get('action')

    token = get_object_or_404(UserToken, id=token_id, user=request.user)
    ai_client = get_object_or_404(AIClientGlobalConfiguration, api_client_class=ai_client_name)

    capture, created = TrainingCapture.objects.get_or_create(token=token, ai_client=ai_client)

    if action == 'activate':
        # Desativar todas as outras capturas ativas do mesmo usuário
        TrainingCapture.objects.filter(is_active=True, token__user=request.user).exclude(id=capture.id).update(is_active=False)

        if not capture.is_active:
            capture.is_active = True
            if not capture.temp_file:
                # Criar um arquivo temporário
                temp_filename = f'temp_capture_{uuid.uuid4().hex}.json'
                temp_file_path = os.path.join(settings.MEDIA_ROOT, 'training_captures', temp_filename)
                
                # Inicializar o arquivo como uma lista vazia
                with open(temp_file_path, 'w') as temp_file:
                    json.dump([], temp_file)
                
                # Salvar o arquivo no campo temp_file
                with open(temp_file_path, 'rb') as f:
                    capture.temp_file.save(temp_filename, File(f), save=True)
                
                # Remover o arquivo temporário após salvar via Django
                os.remove(temp_file_path)
            capture.save()
            status = 'ativada'
        else:
            status = 'já estava ativada'
    elif action == 'deactivate':
        if capture.is_active:
            capture.is_active = False
            capture.save()
            status = 'desativada'
        else:
            status = 'já estava desativada'
    else:
        return JsonResponse({'error': 'Ação inválida.'}, status=400)

    return JsonResponse({'message': f'Captura {status} com sucesso.'})

@login_required
def get_training_examples(request, token_id, ai_client_name):
    token = get_object_or_404(UserToken, id=token_id, user=request.user)
    ai_client = get_object_or_404(AIClientGlobalConfiguration, api_client_class=ai_client_name)
    try:
        capture = TrainingCapture.objects.get(token=token, ai_client=ai_client, is_active=True)
        capture.save() 
        temp_file = capture.temp_file
        if not temp_file:
            return JsonResponse({'examples': []})
        with temp_file.open('r') as f:
            training_data = json.load(f)
        # Limpar o arquivo temporário
        with temp_file.open('w') as f:
            json.dump([], f)
        return JsonResponse({'examples': training_data})
    except TrainingCapture.DoesNotExist:
        return JsonResponse({'error': 'Captura não está ativa.'}, status=400)
    except Exception as e:
        logger.error(f"Erro ao carregar os exemplos: {e}")
        return JsonResponse({'error': 'Erro ao carregar os exemplos.'}, status=500)

=== ai_config/storage.py ===
# ai_config/storage.py

from django.core.files.storage import FileSystemStorage
import os

class OverwriteStorage(FileSystemStorage):
    """
    Subclasse de FileSystemStorage que sobrescreve arquivos existentes com o mesmo nome.
    """
    def get_available_name(self, name, max_length=None):
        """
        Se o nome do arquivo já existir, o remove antes de retornar o nome.
        """
        if self.exists(name):
            self.delete(name)
        return name


=== ai_config/urls.py ===
from django.urls import path
from . import views

app_name = 'ai_config'

urlpatterns = [
    path('manage-ai-configurations/<uuid:token_id>/', views.manage_ai_configurations, name='manage_ai_configurations'),
    path('manage-token-configurations/<uuid:token_id>/', views.manage_token_configurations, name='manage_token_configurations'),
    path('upload-training-file/<uuid:token_id>/', views.upload_training_file, name='upload_training_file'),
    path('manage-training-configurations/<uuid:token_id>/', views.manage_training_configurations, name='manage_training_configurations'),
    path('train-ai/<uuid:token_id>/', views.train_ai, name='train_ai'),
    path('training-file/', views.create_or_edit_training_file, name='create_training_file'),
    path('training-file/<int:file_id>/', views.create_or_edit_training_file, name='edit_training_file'),
    path('download-training-file/<int:file_id>/', views.download_training_file, name='download_training_file'),
    path('delete-training-file/<int:file_id>/', views.delete_training_file, name='delete_training_file'),
    path('toggle-capture/', views.toggle_capture, name='toggle_capture'),
    #path('receive-capture/', views.receive_capture, name='receive_capture'),
    path('get-training-examples/<uuid:token_id>/<str:ai_client_name>/', views.get_training_examples, name='get_training_examples'),
]

=== ai_config/apps.py ===
from django.apps import AppConfig


class AiConfigConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'ai_config'


=== ai_config/templates/ai_config/confirm_delete_training_file.html ===
<!-- ai_config/templates/ai_config/confirm_delete_training_file.html -->

{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2>Confirmar Exclusão</h2>
        <p>Tem certeza de que deseja excluir o arquivo "{{ training_file.file.name|basename }}"?</p>
        <form method="post">
            {% csrf_token %}
            <button type="submit" class="btn btn-danger">Excluir</button>
            <a href="{% url 'manage_tokens' %}" class="btn btn-secondary">Cancelar</a>
        </form>
    </div>
</div>
{% endblock %}


=== ai_config/templates/ai_config/manage_token_configurations.html ===
{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-8">
        <h2 class="mb-4">Configurações para o Token "{{ token.name }}"</h2>
        <form method="post" enctype="multipart/form-data">
            {% csrf_token %}
            {{ form.as_p }}
            <button type="submit" class="btn btn-primary">Salvar Configurações</button>
        </form>
        <a href="{% url 'manage_configurations' token.id %}" class="btn btn-secondary mt-3">Voltar para Configurações do Token</a>
    </div>
</div>
{% endblock %}


=== ai_config/templates/ai_config/upload_training_file.html ===
{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2>Carregar Arquivo de Treinamento</h2>
        <form method="post" enctype="multipart/form-data">
            {% csrf_token %}
            {{ form.as_p }}
            <button type="submit" class="btn btn-primary">Carregar</button>
        </form>
        <a href="{% url 'manage_tokens' %}" class="btn btn-secondary mt-3">Voltar para Gerenciar Tokens</a>
    </div>
</div>
{% endblock %}


=== ai_config/templates/ai_config/manage_ai_configurations.html ===
{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-10">
        <h2 class="mb-4">Configurações de IA para o Token "{{ token.name }}"</h2>
        <form method="post" enctype="multipart/form-data">
            {% csrf_token %}
            <ul class="nav nav-tabs" id="apiTabs" role="tablist">
                {% for ai_form in forms %}
                    <li class="nav-item" role="presentation">
                        <button class="nav-link {% if forloop.first %}active{% endif %}"
                                id="{{ ai_form.ai_client }}-tab"
                                data-bs-toggle="tab"
                                data-bs-target="#{{ ai_form.ai_client }}"
                                type="button"
                                role="tab"
                                aria-controls="{{ ai_form.ai_client }}"
                                aria-selected="{% if forloop.first %}true{% else %}false{% endif %}">
                            {{ ai_form.ai_client }}
                        </button>
                    </li>
                {% endfor %}
            </ul>
            <div class="tab-content mt-3" id="apiTabsContent">
                {% for ai_form in forms %}
                    <div class="tab-pane fade {% if forloop.first %}show active{% endif %}"
                         id="{{ ai_form.ai_client }}"
                         role="tabpanel"
                         aria-labelledby="{{ ai_form.ai_client }}-tab">
                        <div class="card mb-3">
                            <div class="card-body">
                                <h4>{{ ai_form.ai_client }}</h4>
                                <div class="form-check form-switch mb-3">
                                    {{ ai_form.form.enabled }}
                                    {{ ai_form.form.enabled.label_tag }}
                                    {% for error in ai_form.form.enabled.errors %}
                                        <small class="text-danger">{{ error }}</small>
                                    {% endfor %}
                                </div>
                                <div class="mb-3">
                                    {{ ai_form.form.model_name.label_tag }}
                                    {{ ai_form.form.model_name }}
                                    {% for error in ai_form.form.model_name.errors %}
                                        <small class="text-danger">{{ error }}</small>
                                    {% endfor %}
                                </div>
                                <div class="mb-3">
                                    {{ ai_form.form.configurations.label_tag }}
                                    {{ ai_form.form.configurations }}
                                    {% for error in ai_form.form.configurations.errors %}
                                        <small class="text-danger">{{ error }}</small>
                                    {% endfor %}
                                </div>
                            </div>
                        </div>
                    </div>
                {% endfor %}
            </div>
            <button type="submit" class="btn btn-primary">Salvar Configurações</button>
        </form>
        <!-- Botão de Voltar atualizado -->
        <a href="{% url 'manage_configurations' token.id %}" class="btn btn-secondary mt-3">Voltar para Configurações do Token</a>
    </div>
</div>
{% endblock %}


=== ai_config/templates/ai_config/manage_training_configurations.html ===
<!-- ai_config/templates/ai_config/manage_training_configurations.html -->

{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-10">
        <h2 class="mb-4">Parâmetros de Treinamento para o Token "{{ token.name }}"</h2>
        <form method="post">
            {% csrf_token %}
            <ul class="nav nav-tabs" id="trainingTabs" role="tablist">
                {% for ai_form in forms %}
                    <li class="nav-item" role="presentation">
                        <button class="nav-link {% if forloop.first %}active{% endif %}"
                                id="{{ ai_form.ai_client }}-tab"
                                data-bs-toggle="tab"
                                data-bs-target="#{{ ai_form.ai_client }}"
                                type="button"
                                role="tab"
                                aria-controls="{{ ai_form.ai_client }}"
                                aria-selected="{% if forloop.first %}true{% else %}false{% endif %}">
                            {{ ai_form.ai_client }}
                        </button>
                    </li>
                {% endfor %}
            </ul>
            <div class="tab-content mt-3" id="trainingTabsContent">
                {% for ai_form in forms %}
                    <div class="tab-pane fade {% if forloop.first %}show active{% endif %}"
                         id="{{ ai_form.ai_client }}"
                         role="tabpanel"
                         aria-labelledby="{{ ai_form.ai_client }}-tab">
                        <div class="card mb-3">
                            <div class="card-body">
                                <h4>{{ ai_form.ai_client }}</h4>
                                <div class="mb-3">
                                    {{ ai_form.form.training_parameters.label_tag }}
                                    {{ ai_form.form.training_parameters }}
                                    {% for error in ai_form.form.training_parameters.errors %}
                                        <small class="text-danger">{{ error }}</small>
                                    {% endfor %}
                                </div>
                                <div class="mb-3">
                                    {{ ai_form.form.trained_model_name.label_tag }}
                                    {{ ai_form.form.trained_model_name }}
                                </div>
                            </div>
                        </div>
                    </div>
                {% endfor %}
            </div>
            <button type="submit" class="btn btn-primary">Salvar Parâmetros de Treinamento</button>
        </form>
        <!-- Botão de Voltar atualizado -->
        <a href="{% url 'manage_configurations' token.id %}" class="btn btn-secondary mt-3">Voltar para Configurações do Token</a>
    </div>
</div>
{% endblock %}


=== ai_config/templates/ai_config/select_token_for_training_file.html ===
{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <h2>Criar Arquivo de Treinamento</h2>
        <form method="post">
            {% csrf_token %}
            <div class="mb-3">
                <label for="token_id" class="form-label">Selecione o Token</label>
                <select name="token_id" id="token_id" class="form-select" required>
                    <option value="">-- Selecione um Token --</option>
                    {% for token in tokens %}
                        <option value="{{ token.id }}">{{ token.name }}</option>
                    {% endfor %}
                </select>
                {% if form.token_id.errors %}
                    <div class="text-danger">
                        {{ form.token_id.errors }}
                    </div>
                {% endif %}
            </div>
            <button type="submit" name="select_token" class="btn btn-primary">Continuar</button>
            <a href="{% url 'ai_config:manage_tokens' %}" class="btn btn-secondary">Cancelar</a>
        </form>
    </div>
</div>
{% endblock %}


=== ai_config/templates/ai_config/create_training_file.html ===
<!-- ai_config/templates/ai_config/create_training_file.html -->

{% extends 'base.html' %}
{% load ai_config_tags %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-10" id="main-content">
        {% if training_file %}
            <h2>Editar Arquivo de Treinamento: {{ training_file.name }}</h2>
        {% else %}
            <h2>Criar Arquivo de Treinamento</h2>
        {% endif %}
        
        <!-- Barra Flutuante Colapsada para Captura de Consulta -->
        <div id="capture-sidebar" class="sidebar {% if not active_capture or not active_capture.is_active %}collapsed{% endif %}">
            <div class="sidebar-content">
                <h3 class="sidebar-title">Captura de Consulta</h3>
                <form id="capture-form" method="post">
                    {% csrf_token %}
                    {{ capture_form.as_p }}
                    <button type="button" id="toggle-capture-btn" class="btn btn-primary">
                        <i class="bi {% if active_capture and active_capture.is_active %}bi-toggle-on{% else %}bi-toggle-off{% endif %}"></i>
                        {% if active_capture and active_capture.is_active %}
                            Desativar Captura de Consulta
                        {% else %}
                            Ativar Captura de Consulta
                        {% endif %}
                    </button>
                </form>
            </div>
        </div>
        <button id="toggle-sidebar-btn" class="btn btn-secondary">
            <i class="bi"></i>
        </button>

        <form method="post" enctype="multipart/form-data">
            {% csrf_token %}
            {{ form.media }}
            {{ formset.media }}
            <!-- Campo de Nome do Arquivo -->
            <div class="mb-3">
                {{ name_form.name.label_tag }}
                {{ name_form.name }}
                {% for error in name_form.name.errors %}
                    <small class="text-danger">{{ error }}</small>
                {% endfor %}
            </div>
            
            <!-- Formset de Exemplos -->
            {{ formset.management_form }}
            <div id="formset-container">
                {% for form in formset %}
                    <div class="card mb-3 formset-form">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <!-- Área de Colapso Separada -->
                            <div class="collapse-toggle" style="cursor: pointer;" data-bs-toggle="collapse" data-bs-target="#collapse{{ forloop.counter0 }}" aria-expanded="{% if forloop.first and not training_file %}true{% else %}false{% endif %}" aria-controls="collapse{{ forloop.counter0 }}">
                                <h5 class="mb-0">
                                    Exemplo {{ forloop.counter }}
                                    <i class="bi bi-chevron-down ms-2"></i>
                                </h5>
                            </div>
                            <!-- Botão Remover Independente -->
                            <button type="button" class="btn btn-danger btn-sm remove-form">Remover</button>
                        </div>
                        <div id="collapse{{ forloop.counter0 }}" class="collapse {% if forloop.first and not training_file %}show{% endif %}" aria-labelledby="heading{{ forloop.counter0 }}" data-bs-parent="#formset-container">
                            <div class="card-body">
                                <div class="mb-3" style="display: none;">
                                    {{ form.DELETE }}
                                </div>
                                <div class="mb-3">
                                    {{ form.system_message.label_tag }}
                                    {{ form.system_message }}
                                    {% for error in form.system_message.errors %}
                                        <small class="text-danger">{{ error }}</small>
                                    {% endfor %}
                                </div>
                                <div class="mb-3">
                                    {{ form.user_message.label_tag }}
                                    {{ form.user_message }}
                                    {% for error in form.user_message.errors %}
                                        <small class="text-danger">{{ error }}</small>
                                    {% endfor %}
                                </div>
                                <div class="mb-3">
                                    {{ form.response.label_tag }}
                                    {{ form.response }}
                                    {% for error in form.response.errors %}
                                        <small class="text-danger">{{ error }}</small>
                                    {% endfor %}
                                </div>
                            </div>
                        </div>
                    </div>
                {% empty %}
                    <p>Nenhum exemplo adicionado.</p>
                {% endfor %}
            </div>
            <button type="button" id="add-form" class="btn btn-secondary">Adicionar Exemplo</button>
            
            <!-- Botões de Salvamento -->
            {% if training_file %}
                <button type="submit" name="save" class="btn btn-primary">Salvar Alterações</button>
                <button type="submit" name="save_and_continue" class="btn btn-primary">Salvar e Continuar Editando</button>
            {% else %}
                <button type="submit" name="save" class="btn btn-primary">Salvar Arquivo de Treinamento</button>
                <button type="submit" name="save_and_continue" class="btn btn-primary">Salvar e Continuar Editando</button>
            {% endif %}
        </form>
        <a href="{% url 'manage_tokens' %}" class="btn btn-secondary mt-3">Voltar para Gerenciar Tokens</a>
    </div>
</div>

<!-- Modal para mensagens -->
<div class="modal fade" id="captureModal" tabindex="-1" aria-labelledby="captureModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5" id="captureModalLabel">Captura de Consulta</h1>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
      </div>
      <div class="modal-body" id="captureModalBody">
        <!-- Mensagens serão inseridas via JavaScript -->
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
      </div>
    </div>
  </div>
</div>

<style>
    .sidebar {
        position: fixed;
        top: 60px; /* Ajuste conforme necessário */
        right: 0;
        width: 300px;
        height: calc(100% - 60px);
        background-color: #f8f9fa;
        border-left: 1px solid #dee2e6;
        overflow-y: auto;
        overflow-x: hidden;
        transition: transform 0.3s ease;
        z-index: 1000;
    }
    .sidebar.collapsed {
        transform: translateX(100%); /* Move a sidebar completamente para fora da tela */
        visibility: hidden;
        pointer-events: none;
    }
    .sidebar .sidebar-content {
        padding: 20px;
    }
    #toggle-sidebar-btn {
        position: fixed;
        top: 70px; /* Ajuste conforme necessário */
        width: 40px;
        height: 40px;
        border-radius: 5px 0 0 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1001;
        background-color: #6c757d;
        color: white;
        border: none;
        right: 0;
        transition: right 0.3s ease;
    }
    #main-content {
        transition: margin-right 0.3s ease;
    }

    #main-content.content-shifted {
        margin-right: 300px; /* Ajuste este valor para corresponder à largura da sua sidebar */
    }
</style>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        var formsetContainer = document.getElementById('formset-container');
        var addFormButton = document.getElementById('add-form');
        var totalForms = document.querySelector('[name="form-TOTAL_FORMS"]');
        var formNum = parseInt(totalForms.value);
        
        const toggleCaptureBtn = document.getElementById('toggle-capture-btn');
        const aiClientSelect = document.getElementById('id_capture-ai_client');
        const tokenSelect = document.getElementById('id_capture-token');
        const mainContent = document.getElementById('main-content');
        const sidebar = document.getElementById('capture-sidebar');
        const toggleSidebarBtn = document.getElementById('toggle-sidebar-btn');

        let isCapturing = {% if active_capture and active_capture.is_active %}true{% else %}false{% endif %};
        let selectedAIClientId = null;
        let selectedAIClientName = null;
        let selectedTokenId = null; 

        // Desabilitar campos se a captura estiver ativa
        if (isCapturing) {
            aiClientSelect.disabled = true;
            tokenSelect.disabled = true;
        }

        // Verifique o estado inicial da sidebar e ajuste o conteúdo principal
        if (!sidebar.classList.contains('collapsed')) {
            mainContent.classList.add('content-shifted');
        } else {
            mainContent.classList.remove('content-shifted');
        }

        // Funções para atualizar o ícone e a posição do botão
        function updateToggleButtonIcon() {
            const icon = toggleSidebarBtn.querySelector('i');
            if (sidebar.classList.contains('collapsed')) {
                icon.className = 'bi bi-chevron-left';
            } else {
                icon.className = 'bi bi-chevron-right';
            }
        }

        function updateToggleButtonPosition() {
            if (sidebar.classList.contains('collapsed')) {
                toggleSidebarBtn.style.right = '0';
            } else {
                toggleSidebarBtn.style.right = '300px'; // Largura do sidebar
            }
        }

        // Chamada inicial
        updateToggleButtonIcon();
        updateToggleButtonPosition();

        // Evento de clique para alternar o sidebar
        toggleSidebarBtn.addEventListener('click', function() {
            sidebar.classList.toggle('collapsed');
            mainContent.classList.toggle('content-shifted');
            updateToggleButtonIcon();
            updateToggleButtonPosition();
        });

        toggleCaptureBtn.addEventListener('click', function() {
            selectedAIClientId = aiClientSelect.value;
            selectedAIClientName = aiClientSelect.options[aiClientSelect.selectedIndex].text;
            selectedTokenId = tokenSelect.value;
            
            if (!selectedAIClientId) {
                alert('Por favor, selecione uma IA para capturar consultas.');
                return;
            }
            
            if (!selectedTokenId) {
                alert('Por favor, selecione um Token para capturar consultas.');
                return;
            }
            
            if (!isCapturing) {
                // Iniciar a captura
                fetch("{% url 'ai_config:toggle_capture' %}", {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: new URLSearchParams({
                        'token_id': selectedTokenId,
                        'ai_client_id': selectedAIClientName,
                        'action': 'activate'
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        isCapturing = true;
                        toggleCaptureBtn.innerHTML = '<i class="bi bi-toggle-on"></i> Desativar Captura de Consulta';
                        aiClientSelect.disabled = true;
                        tokenSelect.disabled = true;
                        showModal(data.message);
                    } else if (data.error) {
                        showModal(data.error);
                    }
                })
                .catch(error => {
                    console.error('Erro:', error);
                    showModal('Ocorreu um erro ao ativar a captura.');
                });
            } else {
                // Parar a captura
                fetch("{% url 'ai_config:toggle_capture' %}", {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: new URLSearchParams({
                        'token_id': selectedTokenId,
                        'ai_client_id': selectedAIClientName,
                        'action': 'deactivate'
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        isCapturing = false;
                        toggleCaptureBtn.innerHTML = '<i class="bi bi-toggle-off"></i> Ativar Captura de Consulta';
                        aiClientSelect.disabled = false;
                        tokenSelect.disabled = false;
                        showModal(data.message);
                    } else if (data.error) {
                        showModal(data.error);
                    }
                })
                .catch(error => {
                    console.error('Erro:', error);
                    showModal('Ocorreu um erro ao desativar a captura.');
                });
            }
        });
    
        // Função para mostrar mensagens no modal
        function showModal(message) {
            const captureModal = new bootstrap.Modal(document.getElementById('captureModal'));
            document.getElementById('captureModalBody').textContent = message;
            captureModal.show();
        }
    
        // Parar a captura quando o usuário sair da página
        window.addEventListener('beforeunload', function (e) {
            if (isCapturing && selectedAIClientId && selectedTokenId) {
                navigator.sendBeacon("{% url 'ai_config:toggle_capture' %}", new URLSearchParams({
                    'token_id': selectedTokenId,
                    'ai_client_id': selectedAIClientName,
                    'action': 'deactivate'
                }));
            }
        });
    
        // Função para adicionar um novo formulário ao formset
        function addNewForm(system_message = '', user_message = '', response = '') {
            var emptyForm = document.querySelector('.formset-form').cloneNode(true);
            emptyForm.querySelector('.tox-tinymce').remove();
            var regex = new RegExp('form-(\\d+)-', 'g');
            emptyForm.innerHTML = emptyForm.innerHTML.replace(regex, 'form-' + formNum + '-');
            formNum++;
            totalForms.value = formNum;

            emptyForm.querySelector(`#id_form-${formNum-1}-system_message`).value = system_message;
            emptyForm.querySelector(`#id_form-${formNum-1}-user_message`).value = user_message;
            emptyForm.querySelector(`#id_form-${formNum-1}-response`).value = response;
            emptyForm.querySelector(`#id_form-${formNum-1}-DELETE`).value = false;

            emptyForm.querySelector(`#id_form-${formNum-1}-response`).style = '';

            // Atualizar o número do exemplo no cabeçalho
            var header = emptyForm.querySelector('.card-header .collapse-toggle h5');
            header.innerHTML = 'Exemplo ' + formNum + ' <i class="bi bi-chevron-up ms-2"></i>';
        
            // Atualizar o data-bs-target e aria-controls para o novo form
            var newCollapseId = 'collapse' + formNum;
            var newHeadingId = 'heading' + formNum;
        
            emptyForm.querySelector('.collapse-toggle').setAttribute('data-bs-target', '#' + newCollapseId);
            emptyForm.querySelector('.collapse-toggle').setAttribute('aria-controls', newCollapseId);
            emptyForm.querySelector('.collapse').id = newCollapseId;
            emptyForm.querySelector('.collapse').setAttribute('aria-labelledby', newHeadingId);
            emptyForm.querySelector('.collapse').classList.add('show');

            // Atualizar o atributo 'aria-expanded' para true
            emptyForm.querySelector('.collapse-toggle').setAttribute('aria-expanded', 'true');
            
            formsetContainer.appendChild(emptyForm);

            el = emptyForm.querySelector(`#id_form-${formNum-1}-response`);
            initTinyMCE(el);           
        }

        function initTinyMCE(el) {
            if (el.closest('.empty-form') === null) {  // Don't do empty inlines
            var mce_conf = JSON.parse(el.dataset.mceConf);

            // There is no way to pass a JavaScript function as an option
            // because all options are serialized as JSON.
            const fns = [
                'color_picker_callback',
                'file_browser_callback',
                'file_picker_callback',
                'images_dataimg_filter',
                'images_upload_handler',
                'paste_postprocess',
                'paste_preprocess',
                'setup',
                'urlconverter_callback',
            ];
            fns.forEach((fn_name) => {
                if (typeof mce_conf[fn_name] != 'undefined') {
                    if (mce_conf[fn_name].includes('(')) {
                        mce_conf[fn_name] = eval('(' + mce_conf[fn_name] + ')');
                    }
                    else {
                        mce_conf[fn_name] = window[mce_conf[fn_name]];
                    }
                }
            });

            // replace default prefix of 'empty-form' if used in selector
            if (mce_conf.selector && mce_conf.selector.includes('__prefix__')) {
                mce_conf.selector = `#${el.id}`;
            }
            else if (!('selector' in mce_conf)) {
                mce_conf['target'] = el;
            }
            if (el.dataset.mceGzConf) {
                tinyMCE_GZ.init(JSON.parse(el.dataset.mceGzConf));
            }
            if (!tinyMCE.get(el.id)) {
                tinyMCE.init(mce_conf);
            }
            }
        }

    
        // Função para verificar se o último formulário está vazio
        function isLastFormEmpty() {
            var forms = formsetContainer.querySelectorAll('.formset-form:not([style*="display: none"])');
            if (forms.length === 0) {
                return false;
            }
            var lastForm = forms[forms.length - 1];
            var systemMessage = lastForm.querySelector('[name$="-system_message"]').value.trim();
            var userMessage = lastForm.querySelector('[name$="-user_message"]').value.trim();
            var responseField = lastForm.querySelector('[name$="-response"]');
            var response = '';

            if (tinymce.get(responseField.id)) {
                response = tinymce.get(responseField.id).getContent({ format: 'text' }).trim();
            } else {
                response = responseField.value.trim();
            }

            return systemMessage === '' && userMessage === '' && response === '';
        }

        // Ajuste na atualização da lista de exemplos
        setInterval(function() {
            if (isCapturing && selectedTokenId && selectedAIClientName) {
                fetch(`/ai-config/get-training-examples/${selectedTokenId}/${selectedAIClientName}/`)
                .then(response => response.json())
                .then(data => {
                    if (data.examples && data.examples.length > 0) {
                        data.examples.forEach((example) => {
                            if (isLastFormEmpty()) {
                                // Preencher o último formulário vazio
                                var forms = formsetContainer.querySelectorAll('.formset-form:not([style*="display: none"])');
                                var lastForm = forms[forms.length - 1];
                                lastForm.querySelector('[name$="-system_message"]').value = example.system_message;
                                lastForm.querySelector('[name$="-user_message"]').value = example.user_message;

                                var responseField = lastForm.querySelector('[name$="-response"]');
                                if (tinymce.get(responseField.id)) {
                                    tinymce.get(responseField.id).setContent(example.response);
                                } else {
                                    responseField.value = example.response;
                                    initTinyMCE(responseField);
                                }
                            } else {
                                // Adicionar um novo formulário
                                addNewForm(example.system_message, example.user_message, example.response);
                            }
                        });
                    }
                })
                .catch(error => {
                    console.error('Erro ao buscar exemplos:', error);
                });
            }
        }, 5000); // Atualiza a cada 5 segundos
    
        addFormButton.addEventListener('click', function(e) {
            e.preventDefault();
            addNewForm(); // Adiciona um formulário vazio
        });
        
        formsetContainer.addEventListener('click', function(e) {
            if (e.target && e.target.matches('.remove-form')) {
                e.preventDefault();
                var formToRemove = e.target.closest('.formset-form');
                
                // Verifica se o form a ser removido já existe na base de dados (edição)
                // Se sim, marca o checkbox DELETE
                var deleteInput = formToRemove.querySelector('input[type="checkbox"][name$="-DELETE"]');
                if (deleteInput) {
                    deleteInput.checked = true;
                    // Esconder o formulário visualmente
                    formToRemove.style.display = 'none';
                } else {
                    // Se for um novo formulário (criação), simplesmente remove do DOM
                    formToRemove.remove();
                    formNum--;
                    totalForms.value = formNum;
        
                    // Re-numerar os formulários
                    var forms = formsetContainer.querySelectorAll('.formset-form');
                    forms.forEach(function(form, index) {
                        var currentIndex = index;
                        var regex = new RegExp('form-(\\d+)-', 'g');
                        form.innerHTML = form.innerHTML.replace(regex, 'form-' + index + '-');
        
                        // Atualizar o número do exemplo no cabeçalho
                        var header = form.querySelector('.card-header .collapse-toggle h5');
                        header.innerHTML = 'Exemplo ' + (index + 1) + ' <i class="bi bi-chevron-down ms-2"></i>';
        
                        // Atualizar os atributos de controle de colapso
                        var collapseId = 'collapse' + index;
                        form.querySelector('.collapse-toggle').setAttribute('data-bs-target', '#' + collapseId);
                        form.querySelector('.collapse-toggle').setAttribute('aria-controls', collapseId);
                        form.querySelector('.collapse').id = collapseId;
                        form.querySelector('.collapse').setAttribute('aria-labelledby', 'heading' + index);
        
                        // Atualizar o evento de colapso
                        var headerCard = form.querySelector('.collapse-toggle');
                        headerCard.removeEventListener('click', null); // Remove qualquer ouvinte existente
                        headerCard.addEventListener('click', function() {
                            var collapseElement = document.getElementById(collapseId);
                            var bsCollapse = new bootstrap.Collapse(collapseElement, {
                                toggle: true
                            });
                        });
        
                        // Atualizar o ícone
                        var icon = form.querySelector('.collapse-toggle i');
                        if (icon) {
                            icon.classList.remove('bi-chevron-up');
                            icon.classList.add('bi-chevron-down');
                        }
                    });
                }
            }
        });
        
        // Atualizar ícones de collapse
        var collapseElements = document.querySelectorAll('.collapse');
        collapseElements.forEach(function(collapseEl, index) {
            collapseEl.addEventListener('show.bs.collapse', function () {
                var button = collapseEl.previousElementSibling.querySelector('.collapse-toggle i');
                if (button) {
                    button.classList.remove('bi-chevron-down');
                    button.classList.add('bi-chevron-up');
                }
            });
        
            collapseEl.addEventListener('hide.bs.collapse', function () {
                var button = collapseEl.previousElementSibling.querySelector('.collapse-toggle i');
                if (button) {
                    button.classList.remove('bi-chevron-up');
                    button.classList.add('bi-chevron-down');
                }
            });
        });
        
    });
</script>
{% endblock %}

=== ai_config/templates/ai_config/train_ai.html ===
<!-- ai_config/templates/ai_config/train_ai.html -->

{% extends 'base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-10">
        <h2>Treinar IA para o Token "{{ token.name }}"</h2>
        <form method="post">
            {% csrf_token %}
            <input type="hidden" name="action" id="action-field" value="">

            <table class="table table-striped">
                <thead>
                    <tr>
                        <th scope="col"><input type="checkbox" id="select-all"></th>
                        <th scope="col">Nome da IA</th>
                        <th scope="col">Nome do Modelo Treinado</th>
                    </tr>
                </thead>
                <tbody>
                    {% for ai_client in ai_clients_trainable_details %}
                        <tr>
                            <td>
                                <input type="checkbox" name="ai_clients_to_train" value="{{ ai_client.name }}" class="select-ia-checkbox">
                            </td>
                            <td>{{ ai_client.name }}</td>
                            <td>
                                {% if ai_client.trained_model_name %}
                                    {{ ai_client.trained_model_name }}
                                {% else %}
                                    <span class="text-muted">Nenhum modelo treinado</span>
                                {% endif %}
                            </td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>

            <div class="mb-3">
                <button type="submit" class="btn btn-primary me-2" onclick="setAction('train')">Iniciar Treinamento</button>
                <button type="submit" class="btn btn-danger me-2" onclick="setAction('remove_model')">Remover Modelo Treinado</button>
                <a href="{% url 'manage_configurations' token.id %}" class="btn btn-secondary">Voltar</a>
            </div>
        </form>

        {% if ai_clients_not_trainable %}
            <hr>
            <h4>IAs que não podem ser treinadas:</h4>
            <ul>
                {% for ai_client_name in ai_clients_not_trainable %}
                    <li>{{ ai_client_name }}</li>
                {% endfor %}
            </ul>
            <p>Estas IAs não suportam o treinamento. Por favor, inclua o arquivo de treinamento no prompt.</p>
        {% endif %}
    </div>
</div>

<!-- Script para Selecionar/Deselecionar Todas as IAs -->
<script>
    document.getElementById('select-all').addEventListener('change', function() {
        var checkboxes = document.querySelectorAll('.select-ia-checkbox');
        for (var checkbox of checkboxes) {
            checkbox.checked = this.checked;
        }
    });

    function setAction(action) {
        document.getElementById('action-field').value = action;
    }
</script>
{% endblock %}


=== ai_config/admin.py ===
import os
import logging

from django import forms
from django.conf import settings
from django.urls import path
from django.template.response import TemplateResponse
from django.shortcuts import redirect, get_object_or_404
from django.contrib import admin, messages
from django.utils.html import format_html

from tinymce.widgets import TinyMCE

from .models import ( 
    AIClientGlobalConfiguration, 
    AIClientConfiguration, 
    TokenAIConfiguration, 
    AITrainingFile, 
    AIClientTraining,
    DocumentAIConfiguration)
from .forms import (
    AIClientGlobalConfigForm, 
    AIClientConfigurationForm, 
    TokenAIConfigurationForm, 
    AITrainingFileForm, 
    AIClientTrainingForm)

from .utils import perform_training, CLIENT_CLASSES
from api.constants import AI_CLIENT_MAPPING, AIClientType

logger = logging.getLogger(__name__)

class AIClientTrainingInline(admin.StackedInline):
    model = AIClientTraining
    form = AIClientTrainingForm
    extra = 0
    can_delete = True
    verbose_name = "Parâmetros de Treinamento de IA"
    verbose_name_plural = "Parâmetros de Treinamento de IA"
    fields = ['training_parameters', 'trained_model_name']
    readonly_fields = ['trained_model_name'] 

    def get_formset(self, request, obj=None, **kwargs):
        formset = super().get_formset(request, obj, **kwargs)
        return formset

class AIClientGlobalConfigAdmin(admin.ModelAdmin):
    form = AIClientGlobalConfigForm
    list_display = ('api_client_class', 'masked_api_key')
    search_fields = ('api_client_class',)
    list_filter = ('api_client_class',)

    def masked_api_key(self, obj):
        if obj.api_key:
            if len(obj.api_key) > 8:
                return f"{obj.api_key[:4]}****{obj.api_key[-4:]}"
            else:
                return '*' * len(obj.api_key)
        return ""
    masked_api_key.short_description = 'API Key'

    def get_readonly_fields(self, request, obj=None):
        if obj:  # Se 'obj' não for None, é uma edição
            return self.readonly_fields + ('api_client_class',)
        return self.readonly_fields

    def has_add_permission(self, request):
        existing_clients = AIClientGlobalConfiguration.objects.values_list('api_client_class', flat=True)
        all_ai_classes = [client_type.value for client_type in AIClientType]
        missing_clients = set(all_ai_classes) - set(existing_clients)
        return bool(missing_clients)

    def get_form(self, request, obj=None, **kwargs):
        form = super().get_form(request, obj, **kwargs)
        if not obj:  # Se estiver criando uma nova instância
            existing_clients = AIClientGlobalConfiguration.objects.values_list('api_client_class', flat=True)
            available_choices = [
                (client_type.value, client_type.value) 
                for client_type in AIClientType 
                if client_type.value not in existing_clients
            ]
            form.base_fields['api_client_class'].choices = available_choices
        return form

class AIClientConfigurationAdmin(admin.ModelAdmin):  # Atualizado
    form = AIClientConfigurationForm
    list_display = ('token', 'ai_client', 'enabled')
    list_filter = ('ai_client', 'enabled')
    search_fields = ('token__user__email', 'ai_client__api_client_class')
    fields = ('token', 'ai_client', 'enabled', 'model_name', 'configurations')
    inlines = [AIClientTrainingInline]

    def formfield_for_foreignkey(self, db_field, request, **kwargs):
        if db_field.name == "ai_client":
            kwargs["queryset"] = AIClientGlobalConfiguration.objects.filter(
                api_client_class__in=[client_type.value for client_type in AIClientType]
            )
        return super().formfield_for_foreignkey(db_field, request, **kwargs)

class TokenAIConfigurationAdmin(admin.ModelAdmin):
    form = TokenAIConfigurationForm
    list_display = ('token', 'base_instruction', 'prompt', 'responses')
    search_fields = ('token__name', 'token__user__email')
    list_filter = ('token',)

class AIClientGlobalConfigurationForm(admin.ModelAdmin):
    form = AIClientGlobalConfigForm
    list_display = ('api_client_class', 'original_api_key')
    search_fields = ('api_client_class')
    list_filter = ('api_client_class',)

class AITrainingFileAdmin(admin.ModelAdmin):
    form = AITrainingFileForm
    list_display = ('name', 'file', 'uploaded_at', 'train_all_a_is')
    list_filter = ('uploaded_at',)
    search_fields = ('name', 'user__email')
    readonly_fields = ('uploaded_at',)
    
    def train_all_a_is(self, obj):
        return format_html('<a class="button" href="{}">Treinar IAs</a>', f'train_a_is/{obj.id}/')
    train_all_a_is.short_description = 'Treinar todas as IAs'
    train_all_a_is.allow_tags = True
    
    def get_urls(self):
        urls = super().get_urls()
        custom_urls = [
            path('train_a_is/<int:training_file_id>/', self.admin_site.admin_view(self.train_a_is_view), name='train_a_is'),
        ]
        return custom_urls + urls
    
    def train_a_is_view(self, request, training_file_id):
        training_file = get_object_or_404(AITrainingFile, id=training_file_id)
        if request.method == 'POST':
            # Filtra apenas IAs que suportam treinamento
            trainable_ias = [
                ai_type.value for ai_type in AIClientType 
                if CLIENT_CLASSES[ai_type.value].can_train
            ]
            results = perform_training(request.user, training_file.token, trainable_ias)
            
            for ai_name, result in results.items():
                messages.info(request, f"{ai_name}: {result}")
            return redirect('..')

        context = {
            'training_file': training_file,
            'opts': self.model._meta,
            'title': 'Confirmar Treinamento das IAs',
            'trainable_ias': [
                ai_type.value for ai_type in AIClientType 
                if CLIENT_CLASSES[ai_type.value].can_train
            ]
        }
        return TemplateResponse(
            request, 
            'admin/ai_config/train_a_is_confirmation.html', 
            context
        )

class AIClientTrainingAdmin(admin.ModelAdmin):
    form = AIClientTrainingForm
    list_display = ('ai_client_configuration', 'trained_model_name') 
    readonly_fields = ('trained_model_name',)

class DocumentAIConfigurationForm(forms.ModelForm):
    credentials_file = forms.FileField(
        required=False,
        label='Upload Credentials JSON',
        help_text='Faça o upload do arquivo JSON das credenciais do DocumentAI.'
    )

    class Meta:
        model = DocumentAIConfiguration
        fields = ['project_id', 'location', 'processor_id', 'credentials_file']

    def save(self, commit=True):
        instance = super().save(commit=False)
        credentials_file = self.cleaned_data.get('credentials_file')

        if credentials_file:
            credentials_path = os.getenv('GOOGLE_APPLICATION_CREDENTIALS')
            if not credentials_path:
                raise forms.ValidationError('A variável de ambiente GOOGLE_APPLICATION_CREDENTIALS não está definida.')

            full_path = os.path.join(settings.BASE_DIR, credentials_path)
            os.makedirs(os.path.dirname(full_path), exist_ok=True)

            with open(full_path, 'wb+') as destination:
                for chunk in credentials_file.chunks():
                    destination.write(chunk)

            logger.info(f"Arquivo de credenciais do DocumentAI salvo em: {full_path}")

        if commit:
            instance.save()
        return instance

class DocumentAIConfigurationAdmin(admin.ModelAdmin):
    form = DocumentAIConfigurationForm
    list_display = ('project_id', 'location', 'processor_id')
    readonly_fields = ()  # Nenhum campo somente leitura

    def has_add_permission(self, request):
        if DocumentAIConfiguration.objects.exists():
            return False
        return True

admin.site.register(AIClientGlobalConfiguration, AIClientGlobalConfigAdmin)
admin.site.register(AIClientConfiguration, AIClientConfigurationAdmin)
admin.site.register(TokenAIConfiguration, TokenAIConfigurationAdmin)
admin.site.register(AITrainingFile, AITrainingFileAdmin)
admin.site.register(AIClientTraining, AIClientTrainingAdmin)
admin.site.register(DocumentAIConfiguration, DocumentAIConfigurationAdmin)


=== ai_config/models.py ===
import logging
import uuid

from django.db import models
from django.dispatch import receiver
from django.db.models.signals import post_delete
from django.contrib.auth import get_user_model
from django.utils import timezone

from accounts.models import UserToken

from .storage import OverwriteStorage

# Configuração do logger
logger = logging.getLogger(__name__)

User = get_user_model()

class AIClientGlobalConfiguration(models.Model):
    api_client_class = models.CharField(max_length=255, unique=True)
    api_key = models.CharField(max_length=255)

    class Meta:
        verbose_name = "Global - Cliente de IA"
        verbose_name_plural = "Global - Clientes de IA"

    def __str__(self):
        return f"Cliente de IA para {self.api_client_class}"

class AIClientConfiguration(models.Model):  # Renomeado de TokenConfiguration
    token = models.ForeignKey('accounts.UserToken', related_name='configurations', on_delete=models.CASCADE)
    ai_client = models.ForeignKey('AIClientGlobalConfiguration', on_delete=models.CASCADE)
    enabled = models.BooleanField(default=False)
    model_name = models.CharField(max_length=255, blank=True, null=True)
    configurations = models.JSONField(default=dict, blank=True)

    class Meta:
        unique_together = ('token', 'ai_client')  # Cada combinação de token e cliente deve ser única
        verbose_name = "Token - Configuração de Cliente de IA"
        verbose_name_plural = "Token - Configurações de Cliente de IA"

    def __str__(self):
        return f"Configuração para {self.ai_client.api_client_class} do Token {self.token.name}"

class AITrainingFile(models.Model):
    """
    Model para armazenar arquivos de treinamento vinculados ao usuário.
    """
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='training_files')
    name = models.CharField(max_length=255)
    file = models.FileField(upload_to='training_files/', storage=OverwriteStorage())
    uploaded_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Arquivo de Treinamento de {self.user.email} carregado em {self.uploaded_at}"

    class Meta:
        unique_together = ('user', 'name')  # Garante que cada usuário tenha nomes únicos para seus arquivos
        verbose_name = "Arquivo de Treinamento"
        verbose_name_plural = "Arquivos de Treinamento"

@receiver(post_delete, sender=AITrainingFile)
def delete_file_on_model_delete(sender, instance, **kwargs):
    """
    Remove o arquivo físico do sistema de arquivos ao deletar o objeto.
    """
    if instance.file:
        if instance.file.storage.exists(instance.file.name):
            instance.file.delete(save=False)
            logger.debug(f"Arquivo físico deletado via sinal: {instance.file.name}")

class TokenAIConfiguration(models.Model):
    token = models.OneToOneField(UserToken, related_name='ai_configuration', on_delete=models.CASCADE)
    base_instruction = models.TextField(
        blank=True,
        null=True,
        help_text='Instrução base personalizada para este token.'
    )
    prompt = models.TextField(
        blank=True,
        null=True,
        help_text='Prompt personalizado para este token.'
    )
    responses = models.TextField(
        blank=True,
        null=True,
        help_text='Respostas personalizadas para este token.'
    )
    training_file = models.ForeignKey(
        AITrainingFile,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        help_text='Selecione o arquivo de treinamento para este token.'
    )

    class Meta:
        verbose_name = "Token - Configuração de Prompt"
        verbose_name_plural = "Token - Configurações de Prompt"

    def __str__(self):
        return f"Configuração de IA para Token: {self.token.name}"

class AIClientTraining(models.Model):
    """
    Model para armazenar parâmetros de treinamento e nome do modelo treinado para cada AIClientConfiguration.
    """
    ai_client_configuration = models.OneToOneField(AIClientConfiguration, on_delete=models.CASCADE, related_name='training')
    training_parameters = models.JSONField(default=dict, blank=True, help_text="Parâmetros de treinamento para esta configuração de cliente de IA.")
    trained_model_name = models.CharField(max_length=255, blank=True, null=True, editable=False, help_text="Nome do modelo treinado. Não é editável pelo administrador.")

    def __str__(self):
        return f"Treinamento para {self.ai_client_configuration.ai_client.api_client_class} do Token {self.ai_client_configuration.token.name}"

    class Meta:
        verbose_name = "Token - Parâmetros de Treinamento de IA"
        verbose_name_plural = "Token - Parâmetros de Treinamento de IA"

class DocumentAIConfiguration(models.Model):
    project_id = models.CharField(max_length=100)
    location = models.CharField(max_length=50)
    processor_id = models.CharField(max_length=100)

    class Meta:
        verbose_name = "Configuração de Processamento de Documento"
        verbose_name_plural = "Configurações de Processamento de Documento"

    def __str__(self):
        return f"DocumentAI Configuração ({self.project_id})"

class TrainingCapture(models.Model):
    token = models.ForeignKey(UserToken, related_name='training_captures', on_delete=models.CASCADE)
    ai_client = models.ForeignKey('AIClientGlobalConfiguration', on_delete=models.CASCADE)
    is_active = models.BooleanField(default=False)
    temp_file = models.FileField(upload_to='training_captures/', null=True, blank=True)
    create_at = models.DateTimeField(auto_now_add=True)
    last_activity = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('token', 'ai_client')
        verbose_name = "Captura de Treinamento"
        verbose_name_plural = "Capturas de Treinamento"

    def __str__(self):
        status = "Ativa" if self.is_active else "Inativa"
        return f"Captura {status} para {self.ai_client} do Token {self.token.name}"

=== ai_config/forms.py ===
import json
import bleach
from django import forms
from django.forms import formset_factory, BaseFormSet, ModelChoiceField
from django.contrib.auth import get_user_model
from tinymce.widgets import TinyMCE


from .models import (
    AIClientGlobalConfiguration, 
    AIClientConfiguration, 
    TokenAIConfiguration, 
    AITrainingFile, 
    AIClientTraining, 
    TrainingCapture,
    UserToken)

from api.utils.clientsIA import AI_CLIENT_MAPPING

API_CLIENT_CHOICES = [(client_type.value, client_type.value) for client_type in AI_CLIENT_MAPPING.keys()]

ALLOWED_TAGS = bleach.sanitizer.ALLOWED_TAGS.union({
    'p', 'br', 'strong', 'em', 'ul', 'ol', 'li',
    'table', 'tr', 'td', 'th', 'a', 'div', 
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'section'
})
ALLOWED_ATTRIBUTES = {
    '*': ['class', 'style'],
    'a': ['href', 'title'],
    'img': ['src', 'alt', 'title', 'width', 'height'],
}

User = get_user_model()

class BaseTrainingExampleFormSet(BaseFormSet):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.media = forms.Media()
        for form in self.forms:
            self.media += form.media

class AIClientGlobalConfigForm(forms.ModelForm):
    api_client_class = forms.ChoiceField(
        choices=API_CLIENT_CHOICES,
        label='Classe do Cliente de API',
        widget=forms.Select(attrs={'class': 'form-control'}),
        help_text='Selecione a classe do cliente de API.'
    )
    original_api_key = forms.CharField(widget=forms.HiddenInput(), required=False)

    class Meta:
        model = AIClientGlobalConfiguration
        fields = ['api_client_class', 'api_key']

    def __init__(self, *args, **kwargs):
        super(AIClientGlobalConfigForm, self).__init__(*args, **kwargs)
        if self.instance and self.instance.api_key:
            masked_key = self.mask_api_key(self.instance.api_key)
            self.initial['api_key'] = masked_key
            self.initial['original_api_key'] = self.instance.api_key

    def mask_api_key(self, api_key):
        if len(api_key) > 8:
            return f"{api_key[:4]}****{api_key[-4:]}"
        else:
            return '*' * len(api_key)

    def clean_api_key(self):
        api_key = self.cleaned_data.get('api_key')
        original_api_key = self.initial.get('original_api_key')
        masked_key = self.mask_api_key(original_api_key) if original_api_key else ''
        
        if api_key == masked_key:
            return original_api_key
        else:
            return api_key

class AIClientConfigurationForm(forms.ModelForm):
    enabled = forms.BooleanField(
        label='IA Habilitada',
        required=False,
        initial=True,
        widget=forms.CheckboxInput(attrs={'class': 'form-check-input'}),
        help_text='Marque esta opção para habilitar esta IA.'
    )
    model_name = forms.CharField(
        label='Nome do Modelo',
        widget=forms.TextInput(attrs={'class': 'form-control'}),
        required=False,
        help_text='Insira o nome do modelo para esta IA.'
    )
    configurations = forms.CharField(
        label='Configurações da IA:',
        widget=forms.Textarea(attrs={
            'class': 'form-control',
            'placeholder': 'Exemplo:\ntemperature=0.2\ntop_k=10',
            'title': 'Digite as configurações no formato key=value, uma por linha.'
        }),
        help_text='Insira as configurações no formato key=value, uma por linha.',
        required=False
    )

    class Meta:
        model = AIClientConfiguration
        fields = ['enabled', 'model_name', 'configurations']

    def __init__(self, *args, **kwargs):
        super(AIClientConfigurationForm, self).__init__(*args, **kwargs)
        if self.instance:
            configs = self.instance.configurations or {}
            lines = [f"{key}={value}" for key, value in configs.items()]
            self.initial['configurations'] = '\n'.join(lines)
            self.initial['enabled'] = self.instance.enabled
            self.initial['model_name'] = self.instance.model_name

    def clean_configurations(self):
        configurations_text = self.cleaned_data.get('configurations')
        configurations_dict = {}
        if configurations_text.strip():
            for line in configurations_text.strip().splitlines():
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    try:
                        if '.' in value:
                            value = float(value)
                        else:
                            value = int(value)
                    except ValueError:
                        pass
                    configurations_dict[key] = value
                else:
                    raise forms.ValidationError('Cada linha deve estar no formato key=value.')
            return configurations_dict
        else:
            return configurations_dict

class TokenAIConfigurationForm(forms.ModelForm):
    base_instruction = forms.CharField(
        label='Instrução Base',
        widget=forms.Textarea(attrs={
            'class': 'form-control',
            'cols': 100, 
            'rows': 20,
            'placeholder': 'Insira a instrução base personalizada para este token.'
        }),
        required=False,
        help_text='Insira a instrução base personalizada para este token.'
    )
    prompt = forms.CharField(
        label='Prompt',
        widget=forms.Textarea(attrs={
            'class': 'form-control',
            'cols': 100, 
            'rows': 20,
            'placeholder': 'Insira o prompt personalizado para este token.'
        }),
        required=False,
        help_text='Insira o prompt para todas as comparações.'
    )
    responses = forms.CharField(
        label='Respostas',
        widget=TinyMCE(attrs={
            'class': 'tinymce', 
            'cols': 100, 
            'rows': 20
        }),
        required=False,
        help_text='Insira as respostas para todas as comparações.'
    )
    training_file = forms.ModelChoiceField(
        queryset=AITrainingFile.objects.none(),
        required=False,
        label='Arquivo de Treinamento',
        help_text='Selecione o arquivo de treinamento para este token.'
    )

    class Meta:
        model = TokenAIConfiguration
        fields = ['base_instruction', 'prompt', 'responses', 'training_file']

    def __init__(self, *args, **kwargs):
        user = kwargs.pop('user', None)
        super(TokenAIConfigurationForm, self).__init__(*args, **kwargs)
        if user:
            self.fields['training_file'].queryset = AITrainingFile.objects.filter(user=user)
        self.user = user

    def clean_base_instruction(self):
        base_instruction_html = self.cleaned_data.get('base_instruction', '').strip()
        return bleach.clean(base_instruction_html, tags=ALLOWED_TAGS, attributes=ALLOWED_ATTRIBUTES)

    def clean_prompt(self):
        prompt_html = self.cleaned_data.get('prompt', '').strip()
        return bleach.clean(prompt_html, tags=ALLOWED_TAGS, attributes=ALLOWED_ATTRIBUTES)

    def clean_responses(self):
        responses_html = self.cleaned_data.get('responses', '').strip()
        return bleach.clean(responses_html, tags=ALLOWED_TAGS, attributes=ALLOWED_ATTRIBUTES)

class AITrainingFileNameForm(forms.Form):
    name = forms.CharField(
        label='Nome do Arquivo de Treinamento',
        max_length=255,
        widget=forms.TextInput(attrs={'class': 'form-control'}),
        help_text='Insira um nome para identificar facilmente este arquivo de treinamento.'
    )

class TrainingCaptureForm(forms.ModelForm):
    ai_client = forms.ChoiceField(
        choices=API_CLIENT_CHOICES,
        label='Selecione a IA para Capturar',
        required=True,
        widget=forms.Select(attrs={'class': 'form-control'})
    )

    token = ModelChoiceField(
        queryset=UserToken.objects.none(),
        widget=forms.Select(attrs={'class': 'form-control'}),
        label='Selecionar Token para Capturar',
        required=True
    )

    class Meta:
        model = TrainingCapture
        fields = ['token', 'ai_client']

    def __init__(self, *args, **kwargs):
        user = kwargs.pop('user', None)
        super(TrainingCaptureForm, self).__init__(*args, **kwargs)
        if user:
            tokens = UserToken.objects.filter(user=user)
            self.fields['token'].queryset = tokens
        else:
            self.fields['token'].queryset = UserToken.objects.none()
        
        # Definir valores iniciais
        if self.instance and self.instance.pk:
            self.initial['ai_client'] = self.instance.ai_client.api_client_class
            self.fields['token'].initial = self.instance.token

class AITrainingFileForm(forms.ModelForm):
    class Meta:
        model = AITrainingFile
        fields = ['name', 'file']
        widgets = {
            'file': forms.ClearableFileInput(attrs={'class': 'form-control'}),
        }
    
    def clean_file(self):
        file = self.cleaned_data.get('file')
        return file
    
class AIClientTrainingForm(forms.ModelForm):
    training_parameters = forms.CharField(
        label='Parâmetros de Treinamento',
        widget=forms.Textarea(attrs={
            'class': 'form-control',
            'rows': 5,
            'placeholder': 'Exemplo:\nparam1=valor1\nparam2=valor2'
        }),
        help_text='Insira os parâmetros no formato chave=valor, uma por linha.',
        required=False
    )

    trained_model_name = forms.CharField(
        label='Nome do Modelo Treinado',
        required=False,
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'readonly': 'readonly',
        }),
    )

    class Meta:
        model = AIClientTraining
        fields = ['training_parameters']

    def __init__(self, *args, **kwargs):
        super(AIClientTrainingForm, self).__init__(*args, **kwargs)
        if self.instance and self.instance.training_parameters:
            training_lines = [f"{key}={value}" for key, value in self.instance.training_parameters.items()]
            self.initial['training_parameters'] = "\n".join(training_lines)
        else:
            self.initial['training_parameters'] = ""

        # Inicializa o campo 'trained_model_name' com o valor do modelo treinado
        self.fields['trained_model_name'].initial = self.instance.trained_model_name
        self.fields['trained_model_name'].widget.attrs['readonly'] = True

    def clean_trained_model_name(self):
        # Retorna o valor inicial para garantir que não seja modificado
        return self.initial.get('trained_model_name', self.instance.trained_model_name)

    def save(self, commit=True):
        # Garante que 'trained_model_name' não seja alterado
        self.instance.trained_model_name = self.initial.get('trained_model_name', self.instance.trained_model_name)
        return super().save(commit=commit)

    def clean_training_parameters(self):
        configurations_text = self.cleaned_data.get('training_parameters', '').strip()
        configurations_dict = {}
        
        if configurations_text:
            for line_number, line in enumerate(configurations_text.splitlines(), start=1):
                if not line.strip():
                    continue  # Ignora linhas vazias
                if '=' not in line:
                    raise forms.ValidationError(f"Linha {line_number}: '{line}' não está no formato chave=valor.")
                key, value = line.split('=', 1)
                key = key.strip()
                value = value.strip()
                
                if not key:
                    raise forms.ValidationError(f"Linha {line_number}: Chave vazia.")
                if not value:
                    raise forms.ValidationError(f"Linha {line_number}: Valor vazio para a chave '{key}'.")
                
                try:
                    if '.' in value:
                        value = float(value)
                    else:
                        value = int(value)
                except ValueError:
                    pass  # Mantém como string se não for numérico
                
                configurations_dict[key] = value
        
        return configurations_dict

class UserAITrainingFileForm(forms.ModelForm):
    class Meta:
        model = AITrainingFile
        fields = ['file']
        widgets = {
            'file': forms.ClearableFileInput(attrs={'class': 'form-control'}),
        }

    def __init__(self, *args, **kwargs):
        super(UserAITrainingFileForm, self).__init__(*args, **kwargs)
        self.fields['file'].required = True

class TrainAIForm(forms.Form):
    ai_clients_to_train = forms.MultipleChoiceField(
        choices=[],
        widget=forms.CheckboxSelectMultiple,
        label='Selecionar IAs para Treinar',
        required=True,
        help_text='Selecione as IAs que deseja treinar.',
    )

    def __init__(self, *args, **kwargs):
        ai_clients = kwargs.pop('ai_clients', [])
        super(TrainAIForm, self).__init__(*args, **kwargs)
        self.fields['ai_clients_to_train'].choices = [(client.name, client.name) for client in ai_clients]

class TrainingExampleForm(forms.Form):
    system_message = forms.CharField(
        label='Mensagem do Sistema',
        widget=forms.Textarea(attrs={'rows': 10, 'class': 'form-control'}),
        required=False
    )
    user_message = forms.CharField(
        label='Mensagem do Usuário',
        widget=forms.Textarea(attrs={'rows': 10, 'class': 'form-control'}),
        required=True
    )
    response = forms.CharField(
        label='Resposta',
        widget=TinyMCE(attrs={ 
            'cols': 100, 
            'rows': 20
        }),
        required=False,
        help_text='Insira as respostas para todas as comparações.'
    )

    def clean_user_message(self):
        user_message = self.cleaned_data.get('user_message', '')
        # Substitui \n por quebras de linha reais
        user_message = user_message.replace('\\n', '\n')
        return user_message

    def clean_system_message(self):
        system_message = self.cleaned_data.get('system_message', '')
        # Substitui \n por quebras de linha reais, se necessário
        system_message = system_message.replace('\\n', '\n')
        return system_message

    def clean_response(self):
        response = self.cleaned_data.get('response', '')
        # Substitui \n por quebras de linha reais, se necessário
        response = response.replace('\\n', '\n')
        return response

TrainingExampleFormSetFactory = formset_factory(
    TrainingExampleForm,
    formset=BaseTrainingExampleFormSet,
    can_delete=True,
    extra=0
)

=== ai_config/templatetags/ai_config_tags.py ===
from django import template
import os

register = template.Library()

@register.filter
def basename(value):
    return os.path.basename(value)


=== public/views.py ===
from django.shortcuts import render

def index(request):
    return render(request, 'public/index.html')


=== public/urls.py ===
from django.urls import path
from . import views

app_name = 'public'

urlpatterns = [
    path('', views.index, name='index'),  # Mapeia a raiz para a view index
    # Adicione outras rotas públicas aqui
]


=== public/apps.py ===
from django.apps import AppConfig


class PublicConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'public'


=== public/templates/public/index.html ===
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Orientação de Acesso à API</title>
</head>
<body>
    <h1>Bem-vindo à API do ComparadorIA</h1>
    <p>Esta API permite que você compare configurações de redes de computadores de forma automatizada utilizando inteligência artificial.</p>

    <h2>Documentação da API</h2>
    <ul>
        <li><strong>Endpoint de Comparação:</strong> <code>/api/compare/</code></li>
        <li><strong>Método:</strong> POST</li>
        <li><strong>Autenticação:</strong> Token (via header Authorization: Token &lt;seu_token&gt;)</li>
        <li><strong>Formato do JSON:</strong>
            <pre>
{
    "instruction": { ... },
    "instructor_config": { ... },
    "instructor_network": { ... },
    "student_config": { ... },
    "student_network": { ... }
}
            </pre>
        </li>
    </ul>

    <h2>Ações Disponíveis</h2>
    <ul>
        <li><a href="{% url 'login' %}">Login</a></li>
        <li><a href="{% url 'register' %}">Criar Conta</a></li>
    </ul>
</body>
</html>


=== public/admin.py ===
from django.contrib import admin

# Register your models here.


=== public/models.py ===
from django.db import models

# Create your models here.


=== templates/base.html ===
{% load static %}

<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>ComparadorIA</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">
    <!-- Inclua Bootstrap Icons se for usar ícones -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    {{ form.media }}
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container-fluid">
            <a class="navbar-brand" href="/accounts/manage-tokens/">ComparadorIA</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Alternar navegação">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    {% if user.is_authenticated %}
                        <li class="nav-item">
                            <a class="nav-link" href="#">Olá, {{ user.email }}</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="{% url 'logout' %}">Logout</a>
                        </li>
                    {% else %}
                        <li class="nav-item">
                            <a class="nav-link" href="{% url 'login' %}">Login</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="{% url 'register' %}">Cadastrar</a>
                        </li>
                    {% endif %}
                </ul>
            </div>
        </div>
    </nav>
    <div class="container mt-4">
        {% if messages %}
            {% for message in messages %}
                <div class="alert alert-{{ message.tags }} alert-dismissible fade show" role="alert">
                    {{ message }}
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Fechar"></button>
                </div>
            {% endfor %}
        {% endif %}
        {% block content %}
        {% endblock %}
    </div>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Inicializar Tooltips do Bootstrap -->
    <script>
        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
        var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl)
        })
    </script>
    {{ block.super }}
</body>
</html>


=== myproject/urls.py ===
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from accounts.views import CustomConfirmEmailView 

urlpatterns = [
    path('', include('public.urls')),
    path('admin/', admin.site.urls),
    path('accounts/', include('accounts.urls')),
    path('api/', include('api.urls')),  # Inclui as rotas da API

    # Rotas de autenticação via API
    path('dj-rest-auth/', include('dj_rest_auth.urls')),
    path('dj-rest-auth/registration/', include('dj_rest_auth.registration.urls')),

    # Use a nova rota para confirmação de email
    path(
        'account-confirm-email/<str:key>/',
        CustomConfirmEmailView.as_view(),
        name='account_confirm_email',
    ),
    
    path('tinymce/', include('tinymce.urls')),

    # Incluir as URLs do ai_config
    path('ai-config/', include('ai_config.urls')),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)  # Adicionado


=== myproject/settings.py ===
# myproject/settings.py

import os
from pathlib import Path
from dotenv import load_dotenv

load_dotenv()  # Carrega as variáveis de ambiente do arquivo .env

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = os.getenv('SECRET_KEY', 'fallback-secret-key')

#Recupere o path completo do GOOGLE_APPLICATION_CREDENTIALS
os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = str(BASE_DIR / os.getenv('GOOGLE_APPLICATION_CREDENTIALS'))

DEBUG = True

ALLOWED_HOSTS = ['*']

# Application definition
INSTALLED_APPS = [
    # Aplicações padrão do Django
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.sites',

    # Aplicações de terceiros
    'rest_framework',
    'rest_framework.authtoken',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'dj_rest_auth',
    'dj_rest_auth.registration',
    'tinymce',

    # Aplicações locais
    'accounts',
    'api',
    'public',
    'ai_config',
]

SITE_ID = 1

AUTHENTICATION_BACKENDS = (
    'accounts.backends.EmailBackend',  # Seu backend personalizado
    'django.contrib.auth.backends.ModelBackend',
    'allauth.account.auth_backends.AuthenticationBackend',
)

ACCOUNT_AUTHENTICATION_METHOD = "email"
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_USERNAME_REQUIRED = False
ACCOUNT_USER_MODEL_USERNAME_FIELD = None
ACCOUNT_EMAIL_VERIFICATION = "mandatory"  # Garante que a verificação de email é obrigatória
ACCOUNT_AUTHENTICATION_METHOD = 'email'
ACCOUNT_USERNAME_REQUIRED = False

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'accounts.authentication.CustomTokenAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
    'EXCEPTION_HANDLER': 'api.exception_handlers.custom_exception_handler',
}

LOGIN_REDIRECT_URL = '/manage-tokens/'
LOGOUT_REDIRECT_URL = '/accounts/login/'
LOGIN_URL = 'login'  # Nome da URL definida em accounts/urls.py
LOGOUT_URL = 'logout'  # Nome da URL definida em accounts/urls.py

# URLs de redirecionamento após confirmação de email
ACCOUNT_EMAIL_CONFIRMATION_ANONYMOUS_REDIRECT_URL = '/login/'
ACCOUNT_EMAIL_CONFIRMATION_AUTHENTICATED_REDIRECT_URL = '/login/'

# Use a confirmação de email via GET
ACCOUNT_CONFIRM_EMAIL_ON_GET = True

# Desative o uso de HMAC se estiver enfrentando problemas
ACCOUNT_EMAIL_CONFIRMATION_HMAC = False

#EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'  # Para desenvolvimento
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'  # Para produção

# Configurações para SMTP (Exemplo)
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = os.getenv('EMAIL_HOST_USER')
EMAIL_HOST_PASSWORD = os.getenv('EMAIL_HOST_PASSWORD')
DEFAULT_FROM_EMAIL = os.getenv('DEFAULT_FROM_EMAIL')
ADMIN_EMAIL = os.getenv('ADMIN_EMAIL')  # Adicione esta linha para definir o email do administrador

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'api.middleware.GlobalExceptionMiddleware',
]

ROOT_URLCONF = 'myproject.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],  
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',  
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'accounts.context_processors.site_info', 
            ],
        },
    },
]

WSGI_APPLICATION = 'myproject.wsgi.application'

# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = 'pt-br'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = 'static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')  # Adicionado

# Adicione os diretórios de arquivos estáticos adicionais se necessário
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
    # Outras pastas de estáticos
]

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

LOG_DIR = os.path.join(BASE_DIR, 'logs')

# Criar diretório de Log
if not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)

# Ajusta o nível do Log
if DEBUG:
    LOG_LEVEL = 'DEBUG'
else:
    LOG_LEVEL = 'ERROR'

# Configuração do logging
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'standard': {
            'format': '[%(asctime)s] %(levelname)s [%(name)s:%(lineno)s] %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S',
        },
        'simple': {
            'format': '%(levelname)s %(message)s',
        },
    },
    'handlers': {
        'console': {
            'level': LOG_LEVEL,
            'class': 'logging.StreamHandler',
            'formatter': 'standard' if DEBUG else 'simple',
        },
        'root_file': {
            'level': 'DEBUG' if DEBUG else 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'formatter': 'standard',
            'filename': os.path.join(LOG_DIR, 'root.log'),
            'maxBytes': 1024*1024*5,  # 5 MB
            'backupCount': 5,
        },
        'accounts_file': {
            'level': 'DEBUG' if DEBUG else 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'formatter': 'standard',
            'filename': os.path.join(LOG_DIR, 'accounts.log'),
            'maxBytes': 1024*1024*5,  # 5 MB
            'backupCount': 5,
        },
        'api_file': {
            'level': 'DEBUG' if DEBUG else 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'formatter': 'standard',
            'filename': os.path.join(LOG_DIR, 'api.log'),
            'maxBytes': 1024*1024*5,  # 5 MB
            'backupCount': 5,
        },
        'public_file': {
            'level': 'DEBUG' if DEBUG else 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'formatter': 'standard',
            'filename': os.path.join(LOG_DIR, 'public.log'),
            'maxBytes': 1024*1024*5,  # 5 MB
            'backupCount': 5,
        },
        'django_file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'formatter': 'standard',
            'filename': os.path.join(LOG_DIR, 'django.log'),
            'maxBytes': 1024*1024*5,  # 5 MB
            'backupCount': 5,
        },
        'django_request_file': {
            'level': 'ERROR',
            'class': 'logging.handlers.RotatingFileHandler',
            'formatter': 'standard',
            'filename': os.path.join(LOG_DIR, 'django_request.log'),
            'maxBytes': 1024*1024*5,  # 5 MB
            'backupCount': 5,
        },
    },
    'loggers': {
        '': {  # Root logger
            'handlers': ['console', 'root_file'],
            'level': LOG_LEVEL,
            'propagate': True,
        },
        'django': {
            'handlers': ['django_file'],
            'level': 'INFO',
            'propagate': False,
        },
        'django.request': {
            'handlers': ['django_request_file'],
            'level': 'ERROR',
            'propagate': False,
        },
        'accounts': {
            'handlers': ['accounts_file'],
            'level': 'DEBUG' if DEBUG else 'INFO',
            'propagate': False,
        },
        'api': {
            'handlers': ['api_file'],
            'level': 'DEBUG' if DEBUG else 'INFO',
            'propagate': False,
        },
        'public': {
            'handlers': ['public_file'],
            'level': 'DEBUG' if DEBUG else 'INFO',
            'propagate': False,
        },
    }
}

# Arquivos de mídia
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media/')

# Arquivos estáticos
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')  # Adicionado

TINYMCE_DEFAULT_CONFIG = {
    'height': 300,
    'width': '100%',
    'cleanup_on_startup': True,
    'custom_undo_redo_levels': 20,
    'selector': '.tinymce',
    'theme': 'silver',
    'plugins': '''
            save preview 
            table code lists fullscreen insertdatetime nonbreaking
            directionality searchreplace wordcount visualblocks
            visualchars autolink charmap
            ''',
    'toolbar1': '''
            fullscreen preview bold italic underline | fontselect,
            fontsizeselect | forecolor backcolor | alignleft alignright aligncenter alignjustify |
             indent outdent | bullist numlist | outdent indent |
            ''',
    'toolbar2': '''
            undo redo | h1 h2 h3 h4 h5 h6 | table |
            charmap hr pagebreak nonbreaking anchor |
            visualblocks visualchars | code
            ''',
    'contextmenu': 'formats',
    'menubar': False,
    'statusbar': True,
    'branding': False,  # Remove o branding do TinyMCE
    'convert_urls': False,  # Mantém URLs como estão
}

=== requirements.txt ===
annotated-types==0.7.0
anthropic==0.36.2
anyio==4.4.0
asgiref==3.8.1
beautifulsoup4==4.12.3
bleach==6.1.0
cachetools==5.4.0
certifi==2024.7.4
cffi==1.17.1
charset-normalizer==3.3.2
cryptography==43.0.1
defusedxml==0.7.1
distro==1.9.0
dj-rest-auth==6.0.0
Django==4.2.7
django-allauth==0.53.0
django-js-asset==2.2.0
django-tinymce==4.1.0
djangorestframework==3.15.2
djangorestframework-simplejwt==5.2.2
exceptiongroup==1.2.2
filelock==3.16.1
fsspec==2024.9.0
google-ai-generativelanguage==0.6.6
google-api-core==2.19.1
google-api-python-client==2.140.0
google-auth==2.33.0
google-auth-httplib2==0.2.0
google-cloud-documentai==2.32.0
google-generativeai==0.7.2
googleapis-common-protos==1.63.2
grpcio==1.65.4
grpcio-status==1.62.3
gunicorn==22.0.0
h11==0.14.0
httpcore==1.0.5
httplib2==0.22.0
httpx==0.27.0
huggingface-hub==0.26.0
idna==3.7
jiter==0.5.0
Markdown==3.6
oauthlib==3.2.2
openai==1.40.2
packaging==24.1
proto-plus==1.24.0
protobuf==4.25.4
pyasn1==0.6.0
pyasn1_modules==0.4.0
pycparser==2.22
pydantic==2.8.2
pydantic_core==2.20.1
PyJWT==2.9.0
pyparsing==3.1.2
python-dotenv==1.0.1
python3-openid==3.2.0
PyYAML==6.0.2
requests==2.32.3
requests-oauthlib==2.0.0
rsa==4.9
six==1.16.0
sniffio==1.3.1
soupsieve==2.6
sqlparse==0.5.1
tokenizers==0.20.1
tqdm==4.66.5
typing_extensions==4.12.2
uritemplate==4.1.1
urllib3==2.2.2
webencodings==0.5.1
markdown==3.6
markdownify==0.13.1

=== api/constants.py ===
from enum import Enum
from typing import Dict, Optional
from dataclasses import dataclass, field
from datetime import datetime

class AIClientType(Enum):
    CHATGPT = "ChatGPT"
    GEMINI = "Gemini"
    CLAUDE3 = "Claude3"
    PERPLEXITY = "Perplexity"

@dataclass
class AIClientConfig:
    api_key: str
    model_name: str
    base_instruction: str = ""
    prompt: str = ""
    responses: str = ""
    configurations: Dict = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)
    enabled: bool = True
    can_train: bool = False

@dataclass
class ProcessingResult:
    success: bool
    message: str
    data: Optional[Dict] = None
    error: Optional[str] = None

# Mapeamento de tipos de cliente para suas respectivas classes
AI_CLIENT_MAPPING = {
    AIClientType.CHATGPT: "ChatGPTClient",
    AIClientType.GEMINI: "GeminiClient",
    AIClientType.CLAUDE3: "Claude3Client",
    AIClientType.PERPLEXITY: "PerplexityClient"
}

=== api/utils/clientsIA.py ===
import os
import json
import logging
import base64
import tempfile
import time
import html
import requests
import markdown

from dotenv import load_dotenv
from bs4 import BeautifulSoup

# Importações atualizadas
from openai import OpenAI
import google.generativeai as genai
import anthropic

from django.conf import settings
from api.exceptions import FileProcessingError, APICommunicationError, MissingAPIKeyError

from django.template import engines

# Importando o client do Document AI
from google.cloud import documentai_v1 as documentai
from ai_config.models import DocumentAIConfiguration

# Configuração do logger
logger = logging.getLogger(__name__)

# Carrega as variáveis de ambiente do arquivo .env
load_dotenv()


def parsear_html(html: str) -> str:
    """Parseia o HTML fornecido e retorna a div mais externa.

    Args:
        html (str): String contendo o HTML a ser parseado.

    Returns:
        str: HTML da div mais externa ou HTML original se nenhuma div for encontrada.

    Raises:
        ValueError: Se ocorrer um erro durante o parse do HTML.
    """
    function_name = 'parsearHTML'
    try:
        logger.debug(f"{function_name}: Iniciando o parseamento do HTML.")
        soup = BeautifulSoup(html, 'html.parser')
        outer_div = soup.find('div')
        if (outer_div):
            logger.debug(f"{function_name}: Div externa encontrada no HTML.")
            return str(outer_div)
        else:
            logger.warning(f"{function_name}: Nenhuma div encontrada no HTML. Retornando o HTML original.")
            return html
    except Exception as e:
        logger.error(f"{function_name}: Erro ao parsear o HTML: {e}")
        raise ValueError(f"Erro ao parsear o HTML: {e}")


def processar_documento(conteudo_documento: bytes, nome_documento: str) -> str:
    """Processa um documento usando o Google Cloud Document AI.

    Args:
        conteudo_documento (bytes): Conteúdo do documento em bytes.
        nome_documento (str): Nome do arquivo do documento.

    Returns:
        str: Texto extraído do documento.

    Raises:
        FileProcessingError: Se ocorrer um erro no processamento do documento.
    """
    function_name = 'processar_documento'
    logger.debug(f"{function_name}: Iniciando o processamento do documento: {nome_documento}")

    # Configurações do Document AI
    try:
        doc_ai_config = DocumentAIConfiguration.objects.first()
        if not doc_ai_config:
            raise FileProcessingError("Configuração do DocumentAI não encontrada.")
        project_id = doc_ai_config.project_id
        location = doc_ai_config.location
        processor_id = doc_ai_config.processor_id
    except Exception as e:
        logger.error(f"{function_name}: Erro ao obter DocumentAIConfiguration: {e}")
        raise FileProcessingError(f"Erro ao obter DocumentAIConfiguration: {e}")

    try:
        # Instanciar o cliente
        client = documentai.DocumentProcessorServiceClient()

        # Construir o caminho do processador
        nome_processador = client.processor_path(project_id, location, processor_id)

        # Determinar o tipo MIME com base na extensão do arquivo
        _, ext = os.path.splitext(nome_documento)
        ext = ext.lower()
        if ext == '.pdf':
            mime_type = 'application/pdf'
        elif ext in ['.png', '.jpg', '.jpeg']:
            mime_type = f'image/{ext[1:]}'
        else:
            mime_type = 'application/octet-stream'  # Tipo genérico

        # Criar um arquivo temporário para armazenar o conteúdo
        with tempfile.NamedTemporaryFile(suffix=ext, delete=False) as temp_file:
            temp_file.write(conteudo_documento)
            temp_file_path = temp_file.name

        logger.info(f"{function_name}: Arquivo temporário criado: {temp_file_path}")

        # Ler o conteúdo do documento
        with open(temp_file_path, "rb") as f:
            conteudo_documento = f.read()

        # Criar a solicitação de processamento
        request = documentai.ProcessRequest(
            name=nome_processador,
            raw_document=documentai.RawDocument(content=conteudo_documento, mime_type=mime_type)
        )

        # Processar o documento
        resposta = client.process_document(request=request)
        texto_extraido = resposta.document.text
        logger.debug(f"{function_name}: Documento processado com sucesso.")

        # Remover o arquivo temporário
        os.remove(temp_file_path)
        logger.info(f"{function_name}: Arquivo temporário removido: {temp_file_path}")

        return texto_extraido

    except Exception as e:
        logger.error(f"{function_name}: Erro ao processar o documento {nome_documento}: {e}")
        raise FileProcessingError(f"Erro ao processar o documento: {e}")


def extract_text(data: dict) -> str:
    """Extrai texto de um documento fornecido em formato base64.

    Args:
        data (dict): Dicionário contendo 'name' e 'content' em base64.

    Returns:
        str: Texto extraído do documento.

    Raises:
        FileProcessingError: Se ocorrer erro na extração ou processamento.
    """
    function_name = 'extract_text'
    if data is not None:
        name = data.get('name')
        content = data.get('content')

        if not name or not content:
            logger.error(f"{function_name}: Dados de instrução incompletos.")
            raise FileProcessingError("Dados de instrução incompletos.")

        try:
            # Decodifica o conteúdo do arquivo em Base64
            instruction_decoded = base64.b64decode(content)
            logger.debug(f"{function_name}: Conteúdo do arquivo decodificado com sucesso.")
        except Exception as e:
            logger.error(f"{function_name}: Erro ao decodificar o conteúdo do arquivo: {e}")
            raise FileProcessingError(f"Erro ao decodificar o conteúdo do arquivo: {e}")

        try:
            # Processa o documento e extrai o texto
            instruction_text = processar_documento(instruction_decoded, name)
            logger.info(f"{function_name}: Texto da instrução extraído com sucesso.")
            return instruction_text
        except Exception as e:
            logger.error(f"{function_name}: Erro ao processar o documento: {e}")
            raise FileProcessingError(f"Erro ao processar o documento: {e}")

    else:
        logger.error(f"{function_name}: Nenhum dado de instrução fornecido.")
        raise FileProcessingError("Nenhum dado de instrução fornecido.")


from api.constants import AIClientType, AIClientConfig, ProcessingResult, AI_CLIENT_MAPPING

class APIClient:
    """Classe base abstrata para implementação de clientes de IA."""
    name = ''
    can_train = False
    
    def __init__(self, config: AIClientConfig):
        self.api_key = config.api_key
        self.model_name = config.model_name
        self.configurations = config.configurations
        self.base_instruction = config.base_instruction
        self.prompt = config.prompt
        self.responses = config.responses
        if not self.api_key:
            raise MissingAPIKeyError(f"{self.name}: Chave de API não configurada.")
        logger.debug(f"{self.__class__.__name__}.__init__: Inicializado com configurações: {self.configurations}")

    def _render_template(self, template: str, context: dict):
        """
        Carrega o prompt de um arquivo de template e renderiza com o contexto fornecido.
        """
        # Obtenha a engine de templates padrão do Django
        django_engine = engines['django']

        # Crie um template a partir da string
        template_engine = django_engine.from_string(template)

        # Renderize o template com o contexto
        return template_engine.render(context)


    def _prepare_prompts(self, **kwargs) -> dict:
        """
        Prepara os prompts para as IAs com base no tipo de comparação.
        """
        try:
            kwargs['ai_name'] = self.name
            kwargs['answer_format'] = self.responses
            kwargs['can_train'] = self.can_train
            kwargs['train'] = self._prepare_train(**kwargs)
            base_instruction = html.unescape(self._render_template(self.base_instruction, kwargs))
            prompt = html.unescape(self._render_template(self.prompt, kwargs))
            return {
                'base_instruction': base_instruction,
                'user_prompt': prompt
            }
        except Exception as e:
            logger.error(f"{self.__class__.__name__}._prepare_prompts: Nenhuma mensagem retornada.")
            raise APICommunicationError(f"{self.name}: Nenhuma mensagem retornada.")
    
    def _prepare_train(self, **kwargs) -> dict:
        training_file = kwargs.get('training_file')
        training = ''
        if training_file:
            try:
                with training_file.open('r') as f:
                    training_data = json.load(f)
                training_examples = ""
                for example in training_data:
                    system_message = example.get('system_message', '')
                    user_message = example.get('user_message', '')
                    response = example.get('response', '')
                    training_examples += f"Exemplo:\n Mensagem do Usuário {system_message}\n {user_message}\nResposta esperada: {response}\n\n"
                # Adicionar os exemplos ao prompt
                training = f"{training} \n {training_examples}"
            except Exception as e:
                logger.error(f"{self.__class__.__name__}._prepare_train: Erro ao ler o arquivo de treinamento: {e}")
        return training

    def compare(self, data: dict) -> tuple:
        """
        Método unificado para realizar comparações com base no tipo fornecido.
        """
        logger.debug(f"{self.__class__.__name__}.compare: Iniciando comparação.")
        prompts = self._prepare_prompts(**data)
        response = self._call_api(prompts)
        system_message = prompts.get('base_instruction', '')
        user_message = prompts.get('user_prompt', '')
        logger.debug(f"{self.__class__.__name__}.compare: Comparação concluída com sucesso.")
        return (response, system_message, user_message)

    def _call_api(self, prompts: dict) -> str:
        """
        Método abstrato para chamar a API específica. Deve ser implementado pelas subclasses.
        """
        raise NotImplementedError(f"{self.name}: Subclasses devem implementar o método _call_api.")


class ChatGPTClient(APIClient):
    """Cliente para interação com a API do ChatGPT.

    Implementa a interface para comunicação com o modelo GPT da OpenAI,
    incluindo suporte para fine-tuning e geração de respostas.
    """
    name = AIClientType.CHATGPT.value
    can_train = True
    
    def __init__(self, config: AIClientConfig):
        super().__init__(config)
        self.client = OpenAI(api_key=self.api_key)

    def _call_api(self, prompts: dict) -> str:
        """
        Implementa a chamada à API do ChatGPT.
        """
        try:
            system_messages = [
                {
                    "role": "user", # Mudado de system para user, pois a versão 01 não aceita system
                    "content": prompts['base_instruction']
                },
                {
                    "role": "user", 
                    "content": prompts['user_prompt']
                }
            ]

            self.configurations['model'] = self.model_name
            self.configurations['messages'] = system_messages

            response = self.client.chat.completions.create(**self.configurations)

            logger.debug(f"{self.__class__.__name__}._call_api: Chat criado e concluído com sucesso.")

            if not response:
                logger.error(f"{self.__class__.__name__}._call_api: Nenhuma mensagem retornada.")
                raise APICommunicationError(f"{self.name}: Nenhuma mensagem retornada.")

            return parsear_html(response.choices[0].message.content)

        except Exception as e:
            logger.error(f"{self.__class__.__name__}._call_api: Erro ao comunicar com a API: {e}")
            raise APICommunicationError(f"{self.name}: Erro ao comunicar com a API: {e}")

    def train(self, training_file, parameters={}):
        """
        Implementa o treinamento para o ChatGPT.
        """        
        temp_file_path = None  # Inicializa a variável para garantir que exista no finally
        try:
            # Ler o conteúdo JSON do arquivo de treinamento
            with training_file.open('r') as f:
                training_data = json.load(f)
            
            # Certifique-se de que training_data é uma lista de exemplos
            if not isinstance(training_data, list):
                raise ValueError("O arquivo de treinamento deve conter uma lista de exemplos.")
            
            # Converter para JSONL no formato desejado
            jsonl_content = "\n".join([
                json.dumps({
                    "messages": [
                        {"role": "system", "content": example.get("system_message", "")},
                        {"role": "user", "content": example.get("user_message", "")},
                        {"role": "assistant", "content": example.get("response", "")}
                    ]
                }) 
                for example in training_data
            ])
            
            # Salvar o conteúdo JSONL em um arquivo temporário
            with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.jsonl') as temp_file:
                temp_file.write(jsonl_content)
                temp_file_path = temp_file.name
            
            # Criar o arquivo de treinamento via API
            with open(temp_file_path, 'rb') as f:
                ai_training_file = self.client.files.create(
                    file=f,
                    purpose='fine-tune'
                )
            
            # Criar o trabalho de fine-tuning
            fine_tuning_job = self.client.fine_tuning.jobs.create(
                training_file=ai_training_file.id,
                model=self.model_name,
                hyperparameters=parameters
            )

            # Loop para verificar o status do ajuste fino
            while True:
                # Recupere o status atual do trabalho
                status = self.client.fine_tuning.jobs.retrieve(fine_tuning_job.id)
                status_state = status.status

                # Verifique se o trabalho foi concluído
                if status_state == 'succeeded':
                    logger.debug(f"{self.__class__.__name__}.train: Modelo treinado.")
                    return status.fine_tuned_model
                elif status_state == 'failed':
                    raise APICommunicationError(f"{self.name}: {status.error}")
                else:
                    time.sleep(5)

        except Exception as e:
            logger.error(f"{self.__class__.__name__}.train: Erro ao treinar o modelo: {e}")
            raise APICommunicationError(f"{self.name}: Erro ao treinar o modelo: {e}")


class GeminiClient(APIClient):
    """Cliente para interação com a API do Google Gemini.

    Implementa a interface para comunicação com o modelo Gemini do Google,
    incluindo suporte para treinamento e geração de conteúdo.
    """
    name = AIClientType.GEMINI.value
    can_train = True
    
    def __init__(self, config: AIClientConfig):
        super().__init__(config)
        genai.configure(api_key=self.api_key)

    def _call_api(self, prompts: dict) -> str:
        """
        Implementa a chamada à API do Gemini.
        """
        try:
            prompt = prompts['user_prompt']
            system = prompts['base_instruction']

            logger.debug(f"{self.__class__.__name__}._call_api: Iniciando comparação.")

            gemini_config = genai.types.GenerationConfig(
                **self.configurations
            )
            logger.debug(f"{self.__class__.__name__}._call_api: Modelo configurado.")

            model = genai.GenerativeModel(
                model_name=self.model_name, 
                system_instruction=system
            )
            logger.debug(f"{self.__class__.__name__}._call_api: Configuração de geração definida.")

            m = model.generate_content(prompt, generation_config=gemini_config)
            logger.debug(f"{self.__class__.__name__}._call_api: Conteúdo gerado com sucesso.")

            # Utiliza o método parsearHTML
            return parsear_html(m.text)
        except Exception as e:
            logger.error(f"{self.__class__.__name__}._call_api: Erro ao comunicar com a API: {e}")
            raise APICommunicationError(f"{self.name}: Erro ao comunicar com a API: {e}")

    def train(self, training_file, parameters={}):
        """
        Implementa o treinamento para o Gemini.
        """
        try:
            # Ler o conteúdo JSON do arquivo de treinamento
            with training_file.open('r') as f:
                training_data_raw = json.load(f)

            # Preparar os dados de treinamento no formato esperado
            training_data = []
            for example in training_data_raw:
                text_input = example.get('user_message', '')
                output = example.get('response', '')
                training_data.append({'text_input': text_input, 'output': output})

            # Obter os parâmetros de treinamento, usando valores padrão se não fornecidos
            display_name = parameters.get('display_name', 'Fine-tuned Model')
            epoch_count = int(parameters.get('epoch_count', 1))
            batch_size = int(parameters.get('batch_size', 4))
            learning_rate = float(parameters.get('learning_rate', 0.001))
            source_model = "models/"+self.model_name  # Modelo base para fine-tuning

            # Iniciar o treinamento
            operation = genai.create_tuned_model(
                display_name=display_name,
                source_model=source_model,
                epoch_count=epoch_count,
                batch_size=batch_size,
                learning_rate=learning_rate,
                training_data=training_data,
            )
            logger.debug(f"{self.__class__.__name__}.train: Operação de treinamento iniciada com sucesso.")

            # Aguardar a conclusão do treinamento
            while not operation.done():
                logger.debug(f"{self.__class__.__name__}.train: Treinamento em andamento...")
                time.sleep(10)  # Aguarda 10 segundos antes de verificar novamente

            result = operation.result()
            trained_model_name = result.name  # Nome do modelo treinado
            logger.debug(f"{self.__class__.__name__}.train: Treinamento concluído. Modelo treinado: {trained_model_name}")
            return trained_model_name
        except Exception as e:
            logger.error(f"{self.__class__.__name__}.train: Erro ao treinar o modelo: {e}")
            raise APICommunicationError(f"{self.name}: Erro ao treinar o modelo: {e}")


class Claude3Client(APIClient):
    """Cliente para interação com a API do Anthropic Claude 3.

    Implementa a interface para comunicação com o modelo Claude 3,
    focando na geração de respostas precisas.
    """
    name = AIClientType.CLAUDE3.value
    can_train = False
    
    def __init__(self, config: AIClientConfig):
        super().__init__(config)
        self.client = anthropic.Anthropic(api_key=self.api_key)

    def _call_api(self, prompts: dict) -> str:
        """
        Implementa a chamada à API do Claude 3.
        """
        try:
            system = prompts['base_instruction']
            user_prompt = prompts['user_prompt']

            messages = [
                {
                    "role": "user",
                    "content": user_prompt
                }
            ]

            self.configurations['model'] = self.model_name
            self.configurations['system'] = system
            self.configurations['messages'] = messages
            self.configurations['max_tokens'] = self.configurations.get('max_tokens', 1024)

            response = self.client.messages.create(
                **self.configurations
            )

            logger.debug(f"{self.__class__.__name__}._call_api: Mensagem enviada e resposta recebida com sucesso.")

            if not response or not response.content or not response.content[0].text:
                logger.error(f"{self.__class__.__name__}._call_api: Nenhuma mensagem retornada.")
                raise APICommunicationError(f"{self.name}: Nenhuma mensagem retornada.")

            return parsear_html(response.content[0].text)

        except Exception as e:
            logger.error(f"{self.__class__.__name__}._call_api: Erro ao comunicar com a API: {e}")
            raise APICommunicationError(f"{self.name}: Erro ao comunicar com a API: {e}")


class PerplexityClient(APIClient):
    """Cliente para interação com a API da Perplexity.

    Implementa a interface para comunicação com os modelos da Perplexity,
    fornecendo capacidades de geração de texto.
    """
    name = AIClientType.PERPLEXITY.value
    can_train = False

    def __init__(self, config: AIClientConfig):
        super().__init__(config)

    def _call_api(self, prompts: dict) -> str:
        """
        Implementa a chamada à API da Perplexity.
        """
        try:
            url = "https://api.perplexity.ai/chat/completions"

            # Preparar o payload com os prompts e configurações
            payload = {
                "model": self.model_name,
                "messages": [
                    {
                        "role": "system",
                        "content": prompts['base_instruction']
                    },
                    {
                        "role": "user",
                        "content": prompts['user_prompt']
                    }
                ],
            }

            # Atualizar o payload com as configurações adicionais
            if self.configurations:
                payload.update(self.configurations)

            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }

            logger.debug(f"{self.__class__.__name__}._call_api: Enviando solicitação para a API.")
            response = requests.post(url, json=payload, headers=headers)

            # Verificar o status da resposta
            if response.status_code != 200:
                logger.error(f"{self.__class__.__name__}._call_api: API retornou o código de status {response.status_code}")
                raise APICommunicationError(f"{self.name}: API retornou o código de status {response.status_code}")

            response_json = response.json()

            # Extrair o texto gerado da resposta
            generated_text = response_json['choices'][0]['message'].get('content', '')

            if not generated_text:
                logger.error(f"{self.__class__.__name__}._call_api: Nenhum texto retornado na resposta.")
                raise APICommunicationError(f"{self.name}: Nenhum texto retornado na resposta.")

            logger.debug(f"{self.__class__.__name__}._call_api: Resposta recebida com sucesso.")

            generated_text = markdown.markdown(generated_text)
            return parsear_html(generated_text)

        except Exception as e:
            logger.error(f"{self.__class__.__name__}._call_api: Erro ao comunicar com a API: {e}")
            raise APICommunicationError(f"{self.name}: Erro ao comunicar com a API: {e}")


=== api/views.py ===
import logging
import json
from django.http import JsonResponse
from rest_framework.decorators import api_view
from rest_framework import status
from concurrent.futures import ThreadPoolExecutor, as_completed

from api.exceptions import APIClientError, FileProcessingError, MissingAPIKeyError
from api.utils.clientsIA import extract_text
from api.constants import AIClientConfig, AIClientType
from ai_config.utils import CLIENT_CLASSES

from accounts.models import UserToken
from ai_config.models import AIClientGlobalConfiguration, TrainingCapture

logger = logging.getLogger(__name__)

def process_client(ai_type, processed_data, user_token):
    """Processa a requisição para um tipo específico de cliente IA."""
    ai_client_name = ai_type.value
    
    try:
        # Obter o AIClient
        ai_client = AIClientGlobalConfiguration.objects.get(api_client_class=ai_client_name)
        ai_client_config = user_token.configurations.get(ai_client=ai_client)
        
        if not ai_client_config.enabled:
            logger.info(f"{ai_client_name} está desabilitado para este token.")
            return ai_client_name, {"message": "Esta IA está desabilitada."}

        # Criar AIClientConfig em vez de um dicionário simples
        config = AIClientConfig(
            api_key=ai_client.api_key,
            model_name=ai_client_config.model_name,
            configurations=ai_client_config.configurations.copy(),
            base_instruction=user_token.ai_configuration.base_instruction or "",
            prompt=user_token.ai_configuration.prompt or "",
            responses=user_token.ai_configuration.responses or "",
            enabled=True
        )

        # Verificar modelo treinado
        ai_client_training = getattr(ai_client_config, 'training', None)
        if ai_client_training and ai_client_training.trained_model_name:
            config.model_name = ai_client_training.trained_model_name

        # Adicionar arquivo de treinamento aos dados processados
        training_file = user_token.ai_configuration.training_file.file if user_token.ai_configuration.training_file else None
        processed_data['training_file'] = training_file

        # Inicializar e executar o cliente
        client_class = CLIENT_CLASSES[ai_client_name]
        ai_client_instance = client_class(config)
        comparison_result, system_message, user_message = ai_client_instance.compare(processed_data)

        # Gerenciar captura de treinamento
        handle_training_capture(user_token, ai_client, system_message, user_message, comparison_result)

        return ai_client_name, {"response": comparison_result}

    except MissingAPIKeyError as e:
        logger.error(f"Chave de API ausente para {ai_client_name}: {e}")
        return ai_client_name, {"error": "Chave de API não configurada para esta IA."}
    except Exception as e:
        logger.error(f"Erro ao processar {ai_client_name}: {e}")
        return ai_client_name, {"error": str(e)}

def handle_training_capture(user_token, ai_client, system_message, user_message, comparison_result):
    """Gerencia a captura de dados de treinamento."""
    try:
        capture = TrainingCapture.objects.get(token=user_token, ai_client=ai_client)
        if capture.is_active and capture.temp_file:
            try:
                with capture.temp_file.open('r') as f:
                    training_data = json.load(f)
            except json.JSONDecodeError:
                training_data = []

            training_data.append({
                'system_message': system_message,
                'user_message': user_message,
                'response': comparison_result
            })

            with capture.temp_file.open('w') as f:
                json.dump(training_data, f, ensure_ascii=False, indent=4)

            logger.info(f"Exemplo capturado para treinamento: {ai_client.api_client_class}")
    except TrainingCapture.DoesNotExist:
        pass

@api_view(['POST'])
def compare(request):
    """View principal para comparação de textos usando múltiplos modelos de IA."""
    logger.info("Iniciando operação compare.")
    
    # Validar token
    auth_header = request.META.get('HTTP_AUTHORIZATION', '')
    token_key = auth_header.split(' ')[-1] if ' ' in auth_header else auth_header
    try:
        user_token = UserToken.objects.get(key=token_key)
    except UserToken.DoesNotExist:
        logger.error("Token inválido.")
        return JsonResponse({"error": "Token inválido."}, status=status.HTTP_401_UNAUTHORIZED)

    try:
        processed_data = process_request_data(request.data)
        response_ias = process_all_clients(processed_data, user_token)
        logger.info("Operação compare finalizada com sucesso.")
        return JsonResponse({'IAs': response_ias}, status=status.HTTP_200_OK)
    except Exception as e:
        logger.error(f"Erro na operação compare: {e}")
        return JsonResponse({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

def process_request_data(data):
    """Processa e extrai texto de arquivos nos dados da requisição."""
    def process_file_content(obj):
        if isinstance(obj, dict):
            for key, value in obj.items():
                if isinstance(value, dict) and value.get("type") == "file":
                    obj[key] = extract_text(value)
                else:
                    process_file_content(value)
        elif isinstance(obj, list):
            for item in obj:
                process_file_content(item)

    processed_data = data.copy()
    process_file_content(processed_data)
    return processed_data

def process_all_clients(processed_data, user_token):
    """Processa a requisição para todos os clientes IA disponíveis."""
    response_ias = {}
    with ThreadPoolExecutor(max_workers=5) as executor:
        futures = [
            executor.submit(process_client, ai_type, processed_data, user_token)
            for ai_type in AIClientType
        ]

        for future in as_completed(futures):
            client_name, result = future.result()
            response_ias[client_name] = result

    return response_ias


=== api/urls.py ===
from django.urls import path
from . import views

urlpatterns = [
    path('compare/', views.compare, name='compare'),
    # Adicione outras rotas da API aqui
]


=== api/apps.py ===
from django.apps import AppConfig


class ApiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'api'


=== api/exceptions.py ===
class APIClientError(Exception):
    """Erro genérico do APIClient."""
    pass

class FileProcessingError(APIClientError):
    """Erro ao processar arquivos."""
    pass

class APICommunicationError(APIClientError):
    """Erro na comunicação com a API externa."""
    pass

class MissingAPIKeyError(APIClientError):
    """Erro quando a chave de API não está configurada."""
    pass


=== api/admin.py ===
from django.contrib import admin

# Register your models here.


=== api/exception_handlers.py ===
from rest_framework.views import exception_handler
from rest_framework.exceptions import AuthenticationFailed
from rest_framework.response import Response

def custom_exception_handler(exc, context):
    # Chama o manipulador de exceções padrão para obter a resposta inicial
    response = exception_handler(exc, context)
    
    if response is not None:
        # Verifica se a chave 'detail' está presente na resposta
        if 'detail' in response.data:
            # Move o conteúdo de 'detail' para 'error'
            response.data['error'] = response.data.pop('detail')
        elif isinstance(exc, AuthenticationFailed):
            # Exemplo: caso específico para AuthenticationFailed
            response.data = {'error': 'As credenciais de autenticação não foram fornecidas.'}
        # Você pode adicionar outras customizações aqui se necessário

    return response


=== api/models.py ===
from django.db import models


=== api/middleware.py ===
import logging
from django.http import JsonResponse
from .exceptions import APIClientError, FileProcessingError

logger = logging.getLogger(__name__)

class GlobalExceptionMiddleware:
    """
    Middleware para capturar exceções globais e retornar respostas JSON apropriadas
    apenas para requisições que esperam respostas JSON (e.g., APIs).
    """
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        try:
            response = self.get_response(request)
            return response
        except APIClientError as e:
            logger.error(f"Erro do cliente de API: {e}")
            return JsonResponse({"error": str(e)}, status=500)
        except FileProcessingError as e:
            logger.error(f"Erro no processamento de arquivos: {e}")
            return JsonResponse({"error": str(e)}, status=400)
        except Exception as e:
            logger.exception("Erro inesperado:")
            
            # Verifica se a requisição espera JSON
            if request.headers.get('Accept') == 'application/json' or request.path.startswith('/api/'):
                return JsonResponse({"error": "Erro interno do servidor."}, status=500)
            else:
                # Re-raise a exceção para que o Django trate normalmente
                raise


